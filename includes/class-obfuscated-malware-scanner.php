<?php
declare(strict_types=1);

/**
 * Main plugin class for malware scanner
 *
 * @package ObfuscatedMalwareScanner
 */

// If this file is called directly, abort.
if ( ! defined( 'ABSPATH' ) ) {
	die( 'Direct access is not allowed.' );
}

require_once __DIR__ . '/class-oms-config.php';
require_once __DIR__ . '/class-oms-logger.php';
require_once __DIR__ . '/class-oms-utils.php';
require_once __DIR__ . '/class-oms-exception.php';

/**
 * Main plugin class.
 *
 * @phpcs:ignore WordPress.NamingConventions.PrefixAllGlobals.NonPrefixedClassFound -- Main plugin class name.
 */
class Obfuscated_Malware_Scanner {

	public const int RATE_LIMITS = 5;

	/**
	 * Admin notification settings
	 */
	public const array OMS_NOTIFY_ADMIN = array(
		'enabled'                    => true,
		'severity_threshold'         => 'warning',  // Minimum severity level to notify.
		'batch_interval'             => 3600,      // Seconds between notification batches.
		'max_notifications_per_hour' => 10,      // Prevent notification flood.
		'include_context'            => true,       // Include surrounding code context.
		'notification_types'         => array(
			'malware_detected'   => true,
			'zero_byte_files'    => true,
			'permission_changes' => true,
			'critical_errors'    => true,
			'quarantine_actions' => true,
		),
	);

	/**
	 * Logger instance.
	 */
	private OMS_Logger $logger;

	/**
	 * Cache instance.
	 */
	private OMS_Cache $cache;

	/**
	 * Rate limiter instance.
	 */
	private OMS_Rate_Limiter $rate_limiter;

	/**
	 * Security policy instance.
	 */
	private OMS_File_Security_Policy $security_policy;

	/**
	 * Database scanner instance.
	 */
	private OMS_Database_Scanner $database_scanner;

	/**
	 * Quarantine manager instance.
	 */
	private OMS_Quarantine_Manager $quarantine_manager;

	/**
	 * Filesystem instance.
	 */
	private OMS_Filesystem $filesystem;

	/**
	 * Core integrity checker instance.
	 */
	private OMS_Core_Integrity_Checker $core_integrity_checker;

	/**
	 * Plugin directory path.
	 */
	private string $plugin_dir;

	/**
	 * Theme directory path.
	 */
	private string $theme_dir;

	/**
	 * Uploads directory path.
	 */
	private string $uploads_dir;

	/**
	 * API instance.
	 */
	private OMS_API $api;

	/**
	 * Constructor.
	 */
	public function __construct() {
		try {
			$this->logger             = new OMS_Logger();
			$this->cache              = new OMS_Cache();
			$this->rate_limiter       = new OMS_Rate_Limiter( array( 'default' => self::RATE_LIMITS ), $this->logger );
			$this->filesystem         = new OMS_Filesystem();
			$this->security_policy    = new OMS_File_Security_Policy( $this->filesystem );
			$this->quarantine_manager = new OMS_Quarantine_Manager( $this->logger );

			global $wpdb;

			$this->database_scanner       = new OMS_Database_Scanner( $this->logger, $this->cache, $wpdb );
			$this->core_integrity_checker = new OMS_Core_Integrity_Checker( $this->logger );

			$this->plugin_dir  = defined( 'WP_PLUGIN_DIR' ) ? WP_PLUGIN_DIR : '';
			$this->theme_dir   = defined( 'WP_CONTENT_DIR' ) ? WP_CONTENT_DIR . '/themes' : '';
			$this->uploads_dir = defined( 'WP_CONTENT_DIR' ) ? WP_CONTENT_DIR . '/uploads' : '';

			$this->api = new OMS_API( $this->logger, $this );

			$this->logger->info( 'Scanner initialized successfully' );
		} catch ( OMS_Exception $e ) {
			// Log initialization error but don't throw to prevent breaking site.
			if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
				error_log( 'OMS initialization failed: ' . esc_html( $e->getMessage() ) ); // phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_error_log
			}
		}
	}

	/**
	 * Initialize the plugin.
	 */
	public function init(): void {
		try {
			$this->setup_hooks();
			$this->api->init();
		} catch ( OMS_Exception $e ) {
			$this->logger->error( 'Failed to initialize hooks: ' . $e->getMessage() );
		}
	}

	/**
	 * Set up WordPress hooks and filters.
	 *
	 * @throws OMS_Exception If WordPress functions are not available.
	 */
	private function setup_hooks(): void {
		if ( ! function_exists( 'register_activation_hook' ) ) {
			throw new OMS_Exception( 'WordPress functions not available' );
		}

		// Note: Activation hook is registered in the main plugin file (obfuscated-malware-scanner.php)
		// to ensure proper plugin initialization order.

		if ( ! wp_next_scheduled( 'oms_daily_cleanup' ) ) {
			wp_schedule_event( time(), 'daily', 'oms_daily_cleanup' );
		}

		add_action( 'oms_daily_cleanup', array( $this, 'run_full_cleanup' ) );
		add_action( 'added_post_meta', array( $this, 'check_uploaded_file' ), 10, 4 );
		add_filter( 'upload_dir', array( $this, 'sanitize_upload_path' ) );
	}

	/**
	 * Run daily security scan
	 *
	 * Scans all areas for threats and quarantines suspicious files.
	 * Database issues are reported but NOT auto-cleaned (requires manual trigger).
	 */
	public function run_full_cleanup(): void {
		try {
			$this->logger->info( 'Starting daily security scan' );
			$this->cleanup_core_files();
			$this->cleanup_plugins();
			$this->cleanup_themes();
			$this->cleanup_uploads();
			$this->cleanup_quarantine();
			$this->check_file_permissions();
			$this->scan_database(); // Scan only - no auto-cleanup.
			$this->logger->info( 'Daily security scan completed' );
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Daily security scan failed' );
		}
	}

	/**
	 * Verified core files.
	 *
	 * @var array<string>
	 */
	private array $verified_core_files = array();

	/**
	 * Cleanup WordPress core files.
	 */
	private function cleanup_core_files(): void {
		try {
			$this->logger->info( 'Verifying core files...' );
			$results = $this->core_integrity_checker->verify_core_files();

			if ( isset( $results['error'] ) ) {
				$this->logger->error( 'Core verification failed: ' . $results['error'] );
				return;
			}

			// Cache verified files for exclusion in other scans.
			$this->verified_core_files = $results['safe'];
			$this->logger->info( sprintf( 'Verified %d core files', count( $this->verified_core_files ) ) );

			foreach ( $results['modified'] as $file ) {
				$this->logger->warning( 'Core file mismatch: ' . $file );
				// We report but do not auto-repair yet to avoid breaking custom setups.
			}

			foreach ( $results['missing'] as $file ) {
				$this->logger->warning( 'Missing core file: ' . $file );
				// We report but do not auto-repair yet.
			}
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Core file cleanup failed' );
		}
	}


	/**
	 * Sanitize upload directory paths.
	 *
	 * This method filters the upload_dir array to ensure all paths are sanitized
	 * and safe before WordPress uses them. It prevents path traversal attacks
	 * while allowing normal WordPress upload directory operations.
	 *
	 * @param array $upload_dir Array of upload directory data with keys:
	 *                          'path', 'url', 'subdir', 'basedir', 'baseurl', 'error'.
	 * @return array Modified upload directory array with sanitized paths.
	 */
	public function sanitize_upload_path( array $upload_dir ): array {
		// Return early if WordPress flagged an error.
		if ( isset( $upload_dir['error'] ) && $upload_dir['error'] ) {
			return $upload_dir;
		}

		// Sanitize path values to prevent path traversal attacks.
		$keys_to_sanitize = array( 'path', 'basedir' );
		foreach ( $keys_to_sanitize as $key ) {
			if ( isset( $upload_dir[ $key ] ) && is_string( $upload_dir[ $key ] ) ) {
				// Normalize the path first.
				$normalized_path = wp_normalize_path( $upload_dir[ $key ] );

				// Check for path traversal attacks using OMS_Utils::is_path_safe.
				// We use is_path_safe directly instead of sanitize_path to avoid
				// throwing exceptions on normal upload directories (which may have
				// executable bits that are acceptable for directories).
				if ( ! OMS_Utils::is_path_safe( $normalized_path ) ) {
					// Invalid path detected - log and set error message.
					$this->logger->warning( 'Invalid upload path detected (path traversal): ' . esc_html( $upload_dir[ $key ] ) );
					// WordPress expects 'error' to be a string message, not a boolean.
					$upload_dir['error'] = sprintf(
						/* translators: %s: The upload path that was detected as unsafe */
						__( 'Invalid upload path detected: %s', 'obfuscated-malware-scanner' ),
						esc_html( $upload_dir[ $key ] )
					);
					return $upload_dir;
				}

				// Use normalized path.
				$upload_dir[ $key ] = $normalized_path;
			}
		}

		return $upload_dir;
	}

	/**
	 * Validate and sanitize uploaded files.
	 *
	 * @param int    $meta_id Meta ID.
	 * @param int    $post_id Post ID.
	 * @param string $meta_key Meta key.
	 * @param mixed  $meta_value Meta value.
	 */
	/**
	 * Validate and sanitize uploaded files.
	 *
	 * @param int    $meta_id Meta ID.
	 * @param int    $post_id Post ID.
	 * @param string $meta_key Meta key.
	 * @param mixed  $meta_value Meta value.
	 */
	public function check_uploaded_file( int $meta_id, int $post_id, string $meta_key, mixed $meta_value ): void {
		if ( '_wp_attached_file' !== $meta_key ) {
			return;
		}

		$upload_dir = wp_upload_dir();
		if ( ! isset( $upload_dir['basedir'] ) || ! is_string( $upload_dir['basedir'] ) ) {
			$this->logger->error( 'Invalid upload directory configuration: basedir not found' );
			return;
		}

		/** @var string|null $file_path */
		$file_path = null;
		try {
			$file_path = OMS_Utils::sanitize_path( $upload_dir['basedir'] . '/' . (string) $meta_value );

			$validation_result = $this->security_policy->validate_file( $file_path );
			$is_valid          = isset( $validation_result['valid'] ) && $validation_result['valid'];

			if ( ! $is_valid || $this->contains_malware( $file_path ) ) {
				$this->quarantine_file( $file_path );
				wp_delete_attachment( $post_id, true );
				$this->logger->warning( 'Malicious file quarantined: ' . esc_html( $file_path ) );
			}
		} catch ( InvalidArgumentException $e ) {
			$this->logger->error( 'Invalid file path in upload check: ' . $e->getMessage() );
			// Fail safe: if path is invalid, we can't trust it.
		} catch ( OMS_Security_Exception $e ) {
			$this->logger->error( 'Security violation in upload check: ' . $e->getMessage() );
			// Fail safe: quarantine if possible.
			if ( null !== $file_path ) {
				$this->quarantine_file( $file_path );
			}
		} catch ( Throwable $e ) {
			$this->logger->error( 'Unexpected error in upload check: ' . $e->getMessage() );
			// Fail safe logic.
			if ( null !== $file_path ) {
				$this->quarantine_file( $file_path );
			}
		}
	}

	/**
	 * Scan a file for malware patterns with improved obfuscation detection.
	 *
	 * @param string $path File path.
	 * @return bool True if malware detected.
	 */
	public function contains_malware( string $path ): bool {
		try {
			if ( ! file_exists( $path ) || ! is_readable( $path ) ) {
				$this->logger->warning( sprintf( 'File not accessible: %s', esc_html( $path ) ) );
				return true; // Treat inaccessible files as suspicious.
			}

			// Check file size.
			$filesize = filesize( $path );
			if ( false === $filesize ) {
				$this->logger->warning( sprintf( 'Failed to get file size: %s', esc_html( $path ) ) );
				return true; // Treat files with unreadable size as suspicious.
			}
			if ( 0 === $filesize ) {
				$this->logger->warning( sprintf( 'Empty or zero-byte file detected: %s', esc_html( $path ) ) );
				return true; // Treat zero-byte files as suspicious.
			}

			// First check for binary files that shouldn't contain PHP.
			if ( $this->is_binary_file( $path ) && $this->contains_php_code( $path ) ) {
				$this->logger->error( sprintf( 'PHP code found in binary file: %s', esc_html( $path ) ) );
				return true;
			}

			// Scan with new obfuscation patterns first.
			foreach ( OMS_Config::OBFUSCATION_PATTERNS as $pattern ) {
				if ( $this->match_pattern( $path, $pattern['pattern'] ) ) {
					$description = $pattern['description'];
					$this->logger->info(
						sprintf(
							'Detected %s - Path: %s, Pattern: %s',
							esc_html( $description ),
							esc_html( $path ),
							esc_html( $pattern['pattern'] )
						)
					);
					return true;
				}
			}

			// Then check other malicious patterns.
			$chunk_size = $this->calculate_optimal_chunk_size( $filesize );
			return $this->scan_file_chunks( $path, $chunk_size );
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Error scanning file: ' . esc_html( $path ) );
			return true; // Treat exceptions as suspicious.
		}
	}

	/**
	 * Check if a file is a binary file that shouldn't contain PHP code.
	 *
	 * @param string $path File path.
	 * @return bool True if binary file.
	 */
	private function is_binary_file( string $path ): bool {
		$extension = strtolower( pathinfo( $path, PATHINFO_EXTENSION ) );
		return in_array( $extension, array( 'jpg', 'jpeg', 'png', 'gif', 'pdf', 'zip' ), true );
	}

	/**
	 * Check if a file contains PHP code.
	 *
	 * @param string $path File path.
	 * @return bool True if PHP code found.
	 */
	private function contains_php_code( string $path ): bool {
		// Read first 1024 bytes to check for PHP signature.
		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fopen
		$handle = fopen( $path, 'rb' );
		if ( false === $handle ) {
			return false;
		}

		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fread
		$content = fread( $handle, 1024 );
		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fclose
		fclose( $handle );

		if ( false === $content ) {
			return false;
		}

		return 1 === preg_match( '/<\?php|<\?=|\xFF\xD8\xFF\xE0.*<\?php/s', $content );
	}

	/**
	 * Match a pattern against a file with proper error handling.
	 *
	 * @param string $path File path.
	 * @param string $pattern Pattern to match.
	 * @return bool True if pattern matches.
	 * @throws Exception If file cannot be read.
	 */
	private function match_pattern( string $path, string $pattern ): bool {
		try {
			$content = file_get_contents( $path );
			if ( false === $content ) {
				throw new Exception( 'Failed to read file contents' );
			}
			return 1 === preg_match( "/$pattern/i", $content );
		} catch ( Exception $e ) {
			$this->logger->error(
				sprintf(
					'Pattern matching failed - Path: %s, Pattern: %s, Error: %s',
					esc_html( $path ),
					esc_html( $pattern ),
					esc_html( $e->getMessage() )
				)
			);
			return false;
		}
	}

	/**
	 * Scan a file for malware patterns.
	 *
	 * @param string $file_path File path.
	 * @param int    $chunk_size Chunk size.
	 * @return bool True if malware found.
	 * @throws Exception If file cannot be read.
	 */
	public function scan_file_chunks( string $file_path, int $chunk_size ): bool {
		if ( ! is_readable( $file_path ) ) {
			throw new Exception( 'File not readable: ' . esc_html( $file_path ) );
		}

		$file_size = filesize( $file_path );
		if ( 0 === $file_size ) {
			$this->logger->warning( sprintf( 'Zero-byte file detected: %s', esc_html( $file_path ) ) );
			return false; // Zero byte files are not malware (but might be suspicious elsewhere).
		}

		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fopen
		$handle = fopen( $file_path, 'rb' );
		if ( false === $handle ) {
			throw new Exception( 'Failed to open file: ' . esc_html( $file_path ) );
		}

		try {
			$matches              = array();
			$offset               = 0;
			$overlap              = OMS_Config::SCAN_CONFIG['overlap_size']; // Overlap between chunks to catch patterns spanning chunks.
			$suspicious_patterns  = $this->get_malware_patterns();
			$start_time           = microtime( true );
			$last_progress_update = 0;

			while ( ! feof( $handle ) ) {
				// Check for timeout.
				if ( microtime( true ) - $start_time > OMS_Config::SECURITY_CONFIG['max_execution_time'] ) { // 5 minutes timeout.
					throw new Exception( 'Scan timeout for file: ' . esc_html( $file_path ) );
				}

				// Throttle if needed.
				if ( $this->rate_limiter->should_throttle() ) {
					usleep( OMS_Config::SCAN_CONFIG['batch_pause'] * 1000 ); // Pause in milliseconds.
				}

				// Read chunk with overlap.
				// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fread
				$chunk = fread( $handle, $chunk_size + $overlap );
				if ( false === $chunk ) {
					throw new Exception( 'Failed to read chunk from file: ' . esc_html( $file_path ) );
				}

				// Update progress every 5%.
				$progress = ( $offset / $file_size ) * 100;
				if ( $progress - $last_progress_update >= 5 ) {
					$this->logger->info( sprintf( 'Scanning %s: %.1f%% complete', esc_html( basename( $file_path ) ), $progress ) );
					$last_progress_update = $progress;
				}

				// Check for malicious patterns.
				foreach ( $suspicious_patterns as $pattern ) {
					if ( preg_match( $pattern['pattern'], $chunk, $pattern_matches, PREG_OFFSET_CAPTURE ) ) {
						$description = $pattern['description'];
						$matches[]   = array(
							'pattern'     => $pattern['pattern'],
							'description' => $description,
							'offset'      => $offset + $pattern_matches[0][1],
							'match'       => $pattern_matches[0][0],
							'context'     => $this->extract_match_context( $file_path, $pattern['pattern'] ),
						);

						$this->logger->warning(
							sprintf(
								'Found suspicious pattern in %s: %s at offset %d',
								esc_html( basename( $file_path ) ),
								esc_html( $description ),
								$offset + $pattern_matches[0][1]
							)
						);
					}
				}

				// Move back by overlap amount unless at EOF.
				if ( ! feof( $handle ) ) {
					fseek( $handle, $offset + $chunk_size - $overlap );
				}

				$offset += $chunk_size - $overlap;
			}

			// Log completion.
			$scan_time = microtime( true ) - $start_time;
			$this->logger->info(
				sprintf(
					'Completed scanning %s in %.2f seconds. Found %d suspicious patterns.',
					esc_html( basename( $file_path ) ),
					$scan_time,
					count( $matches )
				)
			);

			if ( ! empty( $matches ) ) {
				// Store detailed results for admin review.
				$matches_json = wp_json_encode( $matches );
				$matches_str  = false !== $matches_json ? $matches_json : '[]';
				$this->logger->warning( sprintf( 'Suspicious patterns found in %s: %s', esc_html( $file_path ), esc_html( $matches_str ) ) );
				return true; // File contains suspicious patterns.
			}

			return false; // File is clean.

		} finally {
			// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fclose
			if ( is_resource( $handle ) ) {
				fclose( $handle );
			}
		}
	}

	/**
	 * Get malware patterns.
	 *
	 * @return array Malware patterns.
	 */
	private function get_malware_patterns(): array {
		return OMS_Config::MALWARE_PATTERNS;
	}

	/**
	 * Calculate optimal chunk size based on available memory.
	 *
	 * @param int $filesize Size of the file (optional).
	 * @return int Optimal chunk size in bytes.
	 */
	protected function calculate_optimal_chunk_size( int $filesize = 0 ): int {
		$memory_limit = $this->get_memory_limit();

		// Use 10% of available memory or configured limit.
		$chunk_size = (int) min( $memory_limit * 0.1, OMS_Config::SCAN_CONFIG['max_chunk_size'] );

		// Ensure within bounds.
		$chunk_size = max( $chunk_size, OMS_Config::SCAN_CONFIG['min_chunk_size'] );

		// If file is smaller than chunk size, just use file size (plus buffer).
		if ( $filesize > 0 && $filesize < $chunk_size ) {
			return $filesize + 1024;
		}

		return $chunk_size;
	}

	/**
	 * Extract context around match.
	 *
	 * @param string $file_path Path to file.
	 * @param string $pattern   Matched pattern.
	 * @return string Context string.
	 */
	private function extract_match_context( string $file_path, string $pattern ): string {
		try {
			if ( ! file_exists( $file_path ) || ! is_readable( $file_path ) ) {
				return 'File not accessible';
			}

			// Read file content in chunks to handle large files.
			// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fopen
			$handle = fopen( $file_path, 'r' );
			if ( false === $handle ) {
				return 'Failed to open file';
			}

			$context_str   = '';
			$line_number   = 0;
			$context_lines = 2; // Reduced context for summary.
			$buffer        = array();

			while ( ! feof( $handle ) ) {
				$line = fgets( $handle );
				if ( false === $line ) {
					break;
				}

				++$line_number;
				$buffer[] = array(
					'number'  => $line_number,
					'content' => rtrim( $line ),
				);

				if ( count( $buffer ) > $context_lines * 2 + 1 ) {
					array_shift( $buffer );
				}

				if ( preg_match( $pattern, $line ) ) {
					// We found a match. Build context string and return (first match only for brevity in this context).
					// If we wanted all matches, we'd need to return array or accumulate.
					// The caller expects a string 'context', so we return the context of the first match we find in this pass.
					// Note: scan_file_chunks already found the offset in binary mode. Here we re-scan text mode for context. It's expensive but useful.

					$context_start = max( 0, count( $buffer ) - $context_lines - 1 );
					$context       = array_slice( $buffer, $context_start );

					foreach ( $context as $ctx_line ) {
						$prefix       = $ctx_line['number'] === $line_number ? '>' : ' ';
						$context_str .= sprintf(
							"%s %4d: %s\n",
							$prefix,
							$ctx_line['number'],
							$this->sanitize_output( $ctx_line['content'] )
						);
					}

					break; // Return context for first match found.
				}
			}

			// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fclose
			fclose( $handle );

			return $context_str ?: 'No context found during re-scan';

		} catch ( Exception $e ) {
			return 'Error extracting context: ' . $e->getMessage();
		}
	}

	/**
	 * Sanitize output for display.
	 *
	 * @param string $content Content to sanitize.
	 * @return string Sanitized content.
	 */
	private function sanitize_output( string $content ): string {
		// Remove null bytes and control characters.
		$content = str_replace( "\0", '', $content );
		$content = preg_replace( '/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/', '', $content );

		// Encode special characters for safe display.
		return htmlspecialchars( $content, ENT_QUOTES, 'UTF-8' );
	}

	/**
	 * Get PHP memory limit in bytes.
	 *
	 * @return int Memory limit in bytes.
	 */
	private function get_memory_limit(): int {
		$ini_limit = ini_get( 'memory_limit' );
		if ( '-1' === $ini_limit ) {
			return 1024 * 1024 * 1024; // 1GB default.
		}

		$val  = trim( $ini_limit );
		$last = strtolower( $val[ strlen( $val ) - 1 ] );
		$val  = (int) $val;

		switch ( $last ) {
			case 'g':
				$val *= 1024;
				// Fallthrough.
			case 'm':
				$val *= 1024;
				// Fallthrough.
			case 'k':
				$val *= 1024;
		}

		return $val;
	}


	/**
	 * Get log path.
	 *
	 * @return string Log path.
	 */
	public function get_log_path(): string {
		$log_path = OMS_Config::LOG_CONFIG['path'];
		$this->ensure_directory_secure( $log_path );
		return $log_path;
	}

	/**
	 * Ensure directory exists and is secure.
	 *
	 * @param string $path Directory path.
	 */
	private function ensure_directory_secure( string $path ): void {
		if ( ! is_dir( $path ) ) {
			wp_mkdir_p( $path );
			$htaccess = $path . '/.htaccess';
			if ( ! file_exists( $htaccess ) ) {
				$result = file_put_contents(
					$htaccess,
					'Order deny,allow
Deny from all
Require all denied
'
				);
				if ( false === $result ) {
					$this->logger->error( sprintf( 'Failed to create .htaccess file for directory: %s', esc_html( $htaccess ) ) );
				}
			}
		}
	}

	/**
	 * Quarantine a file with fallback options and safety checks.
	 *
	 * @param string $file_path Path to the file to quarantine.
	 * @return bool True if quarantine succeeded, false otherwise.
	 */
	public function quarantine_file( string $file_path ): bool {
		// Safety check: Never quarantine core files.
		if ( $this->is_core_file( $file_path ) ) {
			$this->logger->error( 'Attempted to quarantine core file: ' . esc_html( $file_path ) );
			return false;
		}

		return $this->quarantine_manager->quarantine_file( $file_path );
	}

	/**
	 * Check if a file is a core WordPress file.
	 *
	 * @param string $path File path.
	 * @return bool True if core file.
	 */
	private function is_core_file( string $path ): bool {
		// Minimal implementation based on verified core files or path location.
		// For now, checks if it's in filtered file list or common core locations avoiding wp-content.
		if ( in_array( $path, $this->verified_core_files, true ) ) {
			return true;
		}

		$normalized = wp_normalize_path( $path );
		$wp_content = wp_normalize_path( WP_CONTENT_DIR );

		// If it's not in wp-content, assume it might be core (simplistic, but standard WP structure).
		// Better to be safe than quarantine wp-settings.php.
		if ( strpos( $normalized, $wp_content ) === false ) {
			// Check against allowed root files.
			$basename = basename( $path );
			if ( in_array( $basename, OMS_Config::CRITICAL_FILES, true ) ) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Handle exceptions with proper logging and notifications.
	 *
	 * @param Exception $e The exception to handle.
	 * @param string    $context Additional context about where the exception occurred.
	 */
	private function handle_exception( Exception $e, string $context = '' ): void {
		$severity = ( $e instanceof OMS_Exception ) ? 'HIGH' : 'CRITICAL';

		// Log the error with full context.
		$this->logger->error(
			sprintf(
				'%s: %s\nStack trace: %s',
				esc_html( $context ),
				esc_html( $e->getMessage() ),
				esc_html( $e->getTraceAsString() )
			)
		);

		// Notify admin based on severity.
		if ( $this->should_notify_admin( $severity ) ) {
			$this->notify_admin( $context, $e );
		}
	}

	/**
	 * Check if admin should be notified based on severity and settings.
	 *
	 * @param string $severity The severity level to check.
	 * @return bool Whether admin should be notified.
	 */
	private function should_notify_admin( string $severity ): bool {
		$severity_level  = OMS_Config::SEVERITY_LEVELS[ $severity ] ?? OMS_Config::SEVERITY_LEVELS['LOW'];
		$threshold_level = OMS_Config::SEVERITY_LEVELS[ OMS_Config::NOTIFICATION_THRESHOLD ];

		return $severity_level >= $threshold_level;
	}

	/**
	 * Send notification to admin.
	 *
	 * @param string    $context The context of the notification.
	 * @param Exception $e The exception that triggered the notification.
	 */
	private function notify_admin( string $context, Exception $e ): void {
		try {
			$admin_email = get_option( 'admin_email' );
			if ( ! $admin_email ) {
				throw new OMS_Exception( 'Admin email not configured' );
			}

			$site_name = get_bloginfo( 'name' );
			$subject   = sprintf( 'Security Alert - %s', esc_html( $site_name ) );

			$body = sprintf(
				"Security issue detected:\n\nContext: %s\nError ID: %s\nTime: %s\nMessage: %s\nStack trace: %s",
				esc_html( $context ),
				esc_html( uniqid( 'OMS_ERR_' ) ),
				esc_html( current_time( 'mysql' ) ),
				esc_html( $e->getMessage() ),
				esc_html( $e->getTraceAsString() )
			);

			wp_mail( $admin_email, $subject, $body );
			$this->logger->info( 'Security notification sent to admin: ' . esc_html( $admin_email ) );
		} catch ( Exception $notify_error ) {
			$this->logger->error( 'Failed to send admin notification: ' . esc_html( $notify_error->getMessage() ) );
		}
	}

	/**
	 * Cleanup plugins.
	 */
	public function cleanup_plugins(): void {
		$this->scan_directory_for_cleanup( $this->plugin_dir, 'plugin' );
	}

	/**
	 * Cleanup themes.
	 */
	public function cleanup_themes() {
		$this->scan_directory_for_cleanup( $this->theme_dir, 'theme' );
	}

	/**
	 * Cleanup uploads.
	 */
	public function cleanup_uploads() {
		$this->scan_directory_for_cleanup( $this->uploads_dir, 'uploads' );
	}


	/**
	 * Generic method to scan a directory and cleanup suspicious files.
	 *
	 * @param string $directory Directory path to scan.
	 * @param string $context   Context name for logging (e.g., 'plugin', 'theme', 'uploads').
	 */
	private function scan_directory_for_cleanup( string $directory, string $context ): void {
		$this->logger->info( "Starting {$context} cleanup" );

		if ( ! is_dir( $directory ) ) {
			$this->logger->warning( ucfirst( $context ) . " directory not found: {$directory}" );
			return;
		}

		try {
			$files = new RecursiveIteratorIterator( new RecursiveDirectoryIterator( $directory ) );
			foreach ( $files as $file ) {
				if ( $file->isFile() ) {
					$path = $file->getPathname();

					// Validate the file.
					$validation_result = $this->validate_file( $path );
					if ( ! is_array( $validation_result ) || ! $validation_result['valid'] ) {
						$reason = is_array( $validation_result ) && isset( $validation_result['reason'] ) ? $validation_result['reason'] : 'Unknown';
						$this->logger->warning( "Suspicious {$context} file detected: " . esc_html( $path ) . ' - Reason: ' . esc_html( $reason ) );
						$this->quarantine_file( $path );
					}
				}
			}
		} catch ( Exception $e ) {
			$this->logger->error( "Error scanning {$context} directory: " . $e->getMessage() );
		}

		$this->logger->info( ucfirst( $context ) . ' cleanup completed' );
	}

	/**
	 * Validate file.
	 *
	 * @param string $path File path.
	 * @return array{valid: bool, reason: string} Validation result.
	 */
	public function validate_file( string $path ): array {
		$this->logger->info( 'Validating file: ' . esc_html( $path ) );

		// Check if it's a verified core file.
		if ( $this->core_integrity_checker->is_verified_core_file( $path, $this->verified_core_files ) ) {
			$this->logger->info( 'Skipping verified core file: ' . esc_html( $path ) );
			return array(
				'valid'  => true,
				'reason' => 'Verified core file',
			);
		}

		try {
			// Check file size.
			$filesize = filesize( $path );
			// Scan config max file size check.
			if ( $filesize > OMS_Config::SCAN_CONFIG['max_file_size'] ) {
				$this->logger->warning(
					sprintf( 'File exceeds maximum size limit: %s (%d bytes)', esc_html( $path ), $filesize )
				);
				return array(
					'valid'  => false,
					'reason' => 'File exceeds maximum size limit',
				);
			}

			// Check file permissions.
			$perms = fileperms( $path ) & 0777;
			if ( $perms > OMS_Config::SCAN_CONFIG['allowed_permissions']['file'] ) {
				$this->logger->warning(
					sprintf( 'File has unsafe permissions: %s (0%o)', esc_html( $path ), $perms )
				);
				return array(
					'valid'  => false,
					'reason' => 'File has unsafe permissions',
				);
			}

			// Skip excluded files.
			$basename = basename( $path );
			if ( in_array( $basename, OMS_Config::SCAN_CONFIG['excluded_files'], true ) ) {
				return array(
					'valid'  => true,
					'reason' => 'File is excluded from scan',
				);
			}

			// Check for zero-byte files.
			if ( 0 === $filesize ) {
				$this->logger->warning( sprintf( 'Zero-byte file detected: %s', esc_html( $path ) ) );
				return array(
					'valid'  => false,
					'reason' => 'Zero-byte file detected',
				);
			}

			// Then check other malicious patterns.
			$chunk_size  = $this->calculate_optimal_chunk_size( $filesize );
			$scan_result = $this->scan_file_chunks( $path, $chunk_size );

			return array(
				'valid'  => ! $scan_result,
				'reason' => $scan_result ? 'Malware detected' : 'Scan passed',
			);

		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Error validating file: ' . esc_html( $path ) );
			return array(
				'valid'  => false,
				'reason' => 'Exception during validation: ' . $e->getMessage(),
			);
		}
	}

	/**
	 * Cleanup quarantine.
	 */
	public function cleanup_quarantine() {
		try {
			$quarantine_path = OMS_Config::QUARANTINE_CONFIG['path'];
			$retention_days  = OMS_Config::QUARANTINE_CONFIG['retention_days'];
			$max_size        = OMS_Config::QUARANTINE_CONFIG['max_size'];

			if ( ! is_dir( $quarantine_path ) ) {
				return;
			}

			$cutoff_time = strtotime( "-{$retention_days} days" );
			$total_size  = 0;
			$files       = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator( $quarantine_path, RecursiveDirectoryIterator::SKIP_DOTS )
			);

			foreach ( $files as $file ) {
				if ( $file->getMTime() < $cutoff_time ) {
					// phpcs:ignore WordPress.WP.AlternativeFunctions.unlink_unlink -- Security requirement: must delete old quarantine files, wp_delete_file() not suitable for bulk operations.
					unlink( $file->getPathname() );
					continue;
				}

				$total_size += $file->getSize();
			}

			// If quarantine exceeds max size, remove oldest files.
			if ( $total_size > $max_size ) {
				$files = iterator_to_array( $files );
				usort(
					$files,
					function ( $a, $b ) {
						return $a->getMTime() - $b->getMTime();
					}
				);

				foreach ( $files as $file ) {
					/**
					 * File object from iterator.
					 *
					 * @var SplFileInfo $file
					 */
					if ( $total_size <= $max_size ) {
						break;
					}
					$total_size -= $file->getSize();
					// phpcs:ignore WordPress.WP.AlternativeFunctions.unlink_unlink -- Security requirement: must delete old quarantine files, wp_delete_file() not suitable for bulk operations.
					unlink( $file->getPathname() );
				}
			}
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Error cleaning up quarantine' );
		}
	}

	/**
	 * Check file permissions.
	 */
	public function check_file_permissions() {
		$this->logger->info( 'Starting file permissions check' );

		$directories = array(
			ABSPATH,
			WP_CONTENT_DIR,
			WP_CONTENT_DIR . '/uploads',
			WP_PLUGIN_DIR,
		);

		$secure_dir_perms  = OMS_Config::SCAN_CONFIG['allowed_permissions']['dir'];
		$secure_file_perms = OMS_Config::SCAN_CONFIG['allowed_permissions']['file'];

		foreach ( $directories as $directory ) {
			$items = new RecursiveIteratorIterator( new RecursiveDirectoryIterator( $directory ) );
			foreach ( $items as $item ) {
				$path = $item->getPathname();

				$current_perms = fileperms( $path ) & 0777;

				if ( $item->isDir() && $current_perms !== $secure_dir_perms ) {
					// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_chmod -- Security requirement: must correct insecure file permissions.
					if ( chmod( $path, $secure_dir_perms ) ) {
						$this->logger->info( 'Corrected directory permissions: ' . esc_html( $path ) );
					} else {
						$this->logger->error( 'Failed to correct directory permissions: ' . esc_html( $path ) );
					}
				} elseif ( $item->isFile() && $current_perms !== $secure_file_perms ) {
					// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_chmod -- Security requirement: must correct insecure file permissions.
					if ( chmod( $path, $secure_file_perms ) ) {
						$this->logger->info( 'Corrected file permissions: ' . esc_html( $path ) );
					} else {
						$this->logger->error( 'Failed to correct file permissions: ' . esc_html( $path ) );
					}
				}
			}
		}

		$this->logger->info( 'File permissions check completed' );
	}


	/**
	 * Scan database for issues (does NOT auto-clean)
	 *
	 * Scans database for malicious content and stores results.
	 * Cleanup must be triggered manually via clean_database_issues().
	 *
	 * @return array{success: bool, message?: string, total?: int, issues?: array} Scan result.
	 */
	public function scan_database(): array {
		try {
			$this->logger->info( 'Starting database security scan' );

			$scan_result = $this->database_scanner->scan_database();

			// Assume scan_result has 'success' key.
			if ( ! isset( $scan_result['success'] ) || ! $scan_result['success'] ) {
				$message = $scan_result['message'] ?? 'Unknown error';
				$this->logger->error( sprintf( 'Database scan failed: %s', esc_html( $message ) ) );
				return $scan_result;
			}

			$total_issues = (int) ( $scan_result['total'] ?? 0 );

			if ( $total_issues > 0 ) {
				$this->logger->warning( sprintf( 'Database scan found %d issue(s)', $total_issues ) );

				// Log details for investigation.
				$issues = $scan_result['issues'] ?? array();
				$this->log_integrity_issues( $issues );
				$this->log_modification_issues( $issues );

				// Store issues for cleanup.
				$this->store_pending_database_issues( $issues );

				// Notify admin of issues found.
				$this->notify_admin_of_database_issues( $scan_result );
			} else {
				$this->logger->info( 'Database scan completed - no issues found' );
				// Clear any previous pending issues.
				delete_option( 'oms_pending_db_issues' );
			}

			return $scan_result;
		} catch ( Exception $e ) {
			$this->logger->error( sprintf( 'Database scan failed: %s', esc_html( $e->getMessage() ) ) );
			return array(
				'success' => false,
				'message' => $e->getMessage(),
			);
		}
	}

	/**
	 * Store pending database issues for manual cleanup
	 *
	 * @param array $issues Issues from database scan.
	 */
	private function store_pending_database_issues( array $issues ): void {
		$pending = array(
			'timestamp' => time(),
			'issues'    => $issues,
		);
		update_option( 'oms_pending_db_issues', $pending, false );
	}

	/**
	 * Get pending database issues awaiting cleanup
	 *
	 * @return array|false Pending issues or false if none.
	 */
	public function get_pending_database_issues(): array|false {
		return get_option( 'oms_pending_db_issues', false );
	}

	/**
	 * Clean database issues (manual trigger only)
	 *
	 * Call this when you want to actually clean the detected issues.
	 * Uses transactions - automatically rolls back on any failure.
	 *
	 * @param array|null $specific_issues Optional specific issues to clean. If null, cleans all pending.
	 * @return array Cleanup result.
	 */
	public function clean_database_issues( ?array $specific_issues = null ): array {
		try {
			$issues_to_clean = $specific_issues;

			if ( null === $issues_to_clean ) {
				$pending = $this->get_pending_database_issues();
				if ( ! $pending || empty( $pending['issues'] ) ) {
					return array(
						'success' => true,
						'cleaned' => 0,
						'message' => 'No pending issues to clean',
					);
				}
				$issues_to_clean = $pending['issues'];
			}

			// Extract malicious content issues (the only type we actually delete).
			$malicious_issues = array();
			if ( isset( $issues_to_clean['content'] ) && is_array( $issues_to_clean['content'] ) ) {
				$malicious_issues = array_filter(
					$issues_to_clean['content'],
					static function ( $issue ) {
						return isset( $issue['type'] ) && 'malicious_content' === $issue['type'];
					}
				);
			}

			if ( empty( $malicious_issues ) ) {
				return array(
					'success' => true,
					'cleaned' => 0,
					'message' => 'No malicious content to clean',
				);
			}

			$this->logger->info( sprintf( 'Starting manual database cleanup for %d issues', count( $malicious_issues ) ) );

			$clean_result = $this->database_scanner->clean_database_content( $malicious_issues );

			if ( $clean_result['success'] ) {
				$this->logger->info( sprintf( 'Database cleanup completed: %d rows cleaned', $clean_result['cleaned'] ?? 0 ) );
				// Clear pending issues after successful cleanup.
				delete_option( 'oms_pending_db_issues' );
			} else {
				$this->logger->error( sprintf( 'Database cleanup failed (rolled back): %s', esc_html( $clean_result['message'] ?? 'Unknown error' ) ) );
			}

			return $clean_result;
		} catch ( Exception $e ) {
			$this->logger->error( sprintf( 'Database cleanup failed: %s', esc_html( $e->getMessage() ) ) );
			return array(
				'success' => false,
				'message' => $e->getMessage(),
			);
		}
	}

	/**
	 * Notify admin of database issues found
	 *
	 * @param array $scan_result Scan results.
	 */
	private function notify_admin_of_database_issues( array $scan_result ): void {
		$total = (int) ( $scan_result['total'] ?? 0 );

		// Store admin notice for display.
		set_transient(
			'oms_admin_notice_db_issues',
			array(
				'count'     => $total,
				'timestamp' => time(),
			),
			DAY_IN_SECONDS
		);

		// Send email if configured (filterable).
		$notify_enabled = defined( 'OMS_NOTIFY_ADMIN' ) ? constant( 'OMS_NOTIFY_ADMIN' ) : false;
		if ( apply_filters( 'oms_notify_admin_enabled', $notify_enabled ) ) {
			$admin_email = get_option( 'admin_email' );
			$site_name   = get_bloginfo( 'name' );
			$site_url    = home_url();

			$subject = sprintf( '[%s] Database Security Alert: %d issues found', $site_name, $total );

			$current_time = wp_date( 'Y-m-d H:i:s' );
			$message      = sprintf(
				"Security scan detected %d potential issue(s) in your database.\n\n" .
				"Site: %s\n" .
				"URL: %s\n" .
				"Time: %s\n\n" .
				"Malicious content will be automatically cleaned (transaction-protected).\n" .
				"Review the scan logs for details:\n%s\n",
				$total,
				$site_name,
				$site_url,
				$current_time ? $current_time : gmdate( 'Y-m-d H:i:s' ),
				admin_url( 'admin.php?page=obfuscated-malware-scanner' )
			);

			wp_mail( $admin_email, $subject, $message );
		}
	}

	/**
	 * Scan and clean database (automatic mode)
	 *
	 * Scans for malicious content and automatically cleans it.
	 * Uses transactions - automatically rolls back on any failure.
	 * All actions are logged for investigation.
	 */
	public function cleanup_database(): void {
		$scan_result = $this->scan_database();

		// Check if scan reported success and we have issues.
		// Note from scan_database logic: it returns array.
		if ( ! isset( $scan_result['success'] ) || ! $scan_result['success'] ) {
			return;
		}

		// Auto-clean if issues found.
		$pending = $this->get_pending_database_issues();
		if ( $pending && ! empty( $pending['issues'] ) ) {
			$this->logger->info( 'Auto-cleaning database issues (transaction-protected)' );
			$clean_result = $this->clean_database_issues();

			$cleaned_count = isset( $clean_result['cleaned'] ) ? (int) $clean_result['cleaned'] : 0;
			if ( $clean_result['success'] && $cleaned_count > 0 ) {
				$this->logger->warning(
					sprintf(
						'AUTO-CLEANED %d malicious database entries. Check logs for details.',
						$cleaned_count
					)
				);
			}
		}
	}

	/**
	 * Log integrity issues
	 *
	 * @param array $issues Issues array from database scan.
	 */
	private function log_integrity_issues( array $issues ): void {
		if ( ! isset( $issues['integrity'] ) || ! is_array( $issues['integrity'] ) || empty( $issues['integrity'] ) ) {
			return;
		}

		foreach ( $issues['integrity'] as $issue ) {
			$message = isset( $issue['message'] ) ? $issue['message'] : 'Unknown';
			$this->logger->warning( sprintf( 'Database integrity issue: %s', esc_html( $message ) ) );
		}
	}

	/**
	 * Log modification issues
	 *
	 * @param array $issues Issues array from database scan.
	 */
	private function log_modification_issues( array $issues ): void {
		if ( ! isset( $issues['modifications'] ) || ! is_array( $issues['modifications'] ) || empty( $issues['modifications'] ) ) {
			return;
		}

		foreach ( $issues['modifications'] as $issue ) {
			$message = isset( $issue['message'] ) ? $issue['message'] : 'Unknown';
			$this->logger->warning( sprintf( 'Suspicious database modification: %s', esc_html( $message ) ) );
		}
	}

	/**
	 * Critical error handler.
	 *
	 * @param string $message Error message.
	 */
	public function critical( string $message ): void {
		// Log critical error with timestamp and backtrace.
		$timestamp = current_time( 'mysql' );
		$caller    = 'unknown';
		if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
			$backtrace = debug_backtrace( DEBUG_BACKTRACE_IGNORE_ARGS, 3 ); // phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_debug_backtrace
			$caller    = isset( $backtrace[1] ) ? $backtrace[1]['function'] : 'unknown';
		}

		$log_message = sprintf(
			'[%s] CRITICAL ERROR in %s: %s',
			$timestamp,
			$caller,
			$message
		);

		// Log to WordPress error log only when WP_DEBUG is enabled.
		if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
			// phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_error_log
			error_log( $log_message );
		}

		// Log to our custom log.
		$this->logger->error( $log_message );

		// Notify admin if notifications are enabled.
		if ( get_option( 'oms_email_notifications', true ) ) {
			$admin_email = get_option( 'admin_email' );
			$site_name   = get_bloginfo( 'name' );

			$subject = 'Critical Security Alert - ' . $site_name;
			$body    = sprintf(
				"Critical security issue detected:\n\nError ID: %s\nTime: %s\nMessage: %s\n%s",
				uniqid( 'OMS_ERR_' ),
				$timestamp,
				$message,
				self::OMS_NOTIFY_ADMIN['include_context'] ? "\nContext: " . $caller : ''
			);

			wp_mail( $admin_email, $subject, $body );

			// Store in database for audit trail.
			if ( function_exists( 'update_option' ) ) {
				$audit_log   = get_option( 'oms_security_audit_log', array() );
				$audit_log[] = array(
					'timestamp' => $timestamp,
					'level'     => 'CRITICAL',
					'message'   => $message,
					'caller'    => $caller,
				);

				// Keep only last 100 entries.
				if ( count( $audit_log ) > 100 ) {
					$audit_log = array_slice( $audit_log, -100 );
				}

				update_option( 'oms_security_audit_log', $audit_log );
			}
		}
	}

	/**
	 * Return basic status information for the admin screen.
	 *
	 * @return array Status information.
	 */
	public function get_status(): array {
		return array(
			'last_scan'     => get_option( 'oms_last_scan', 'never' ),
			'files_scanned' => (int) get_option( 'oms_files_scanned', 0 ),
			'issues_found'  => (int) get_option( 'oms_issues_found', 0 ),
			'issues'        => array(),
		);
	}

	/**
	 * Set security policy instance.
	 *
	 * @param OMS_File_Security_Policy $policy Security policy instance.
	 */
	public function set_security_policy( OMS_File_Security_Policy $policy ): void {
		$this->security_policy = $policy;
	}

	/**
	 * Set logger instance.
	 *
	 * @param OMS_Logger $logger Logger instance.
	 */
	public function set_logger( OMS_Logger $logger ): void {
		$this->logger = $logger;
	}
}
