<?php

/**
 * Main plugin class for malware scanner
 *
 * @package ObfuscatedMalwareScanner
 */

use PSpell\Config;

if (!defined('ABSPATH')) {
	die('Direct access is not allowed.');
}

require_once __DIR__ . '/class-oms-config.php';
require_once __DIR__ . '/class-oms-logger.php';
require_once __DIR__ . '/class-oms-utils.php';
require_once __DIR__ . '/class-oms-exception.php';

/**
 * Main plugin class.
 */
class Obfuscated_Malware_Scanner
{
	/** @var OMS_Logger */
	private $logger;

	/** @var OMS_Exception */
	private $exception;

	/** @var array */
	private $compiledPatterns;

	const RATE_LIMITS = 5; // Define RATE_LIMITS constant
	const BACKDOOR_PATTERNS = []; // Define  
	/**
	 * Admin notification settings
	 */
	const OMS_NOTIFY_ADMIN = [
		'enabled' => true,
		'severity_threshold' => 'warning',  // minimum severity level to notify
		'batch_interval' => 3600,          // seconds between notification batches
		'max_notifications_per_hour' => 10, // prevent notification flood
		'include_context' => true,         // include surrounding code context
		'notification_types' => [
			'malware_detected' => true,
			'zero_byte_files' => true,
			'permission_changes' => true,
			'critical_errors' => true,
			'quarantine_actions' => true
		]
	];

	private $cache;
	private $rateLimiter;
	private $securityPolicy;
	private $scanner;

	public function __construct()
	{
		try {
			$this->logger = new OMS_Logger();
			$this->compiledPatterns = $this->loadOrCompilePatterns();
			$this->logger->info('Scanner initialized successfully');
		} catch (OMS_Exception $e) {
			// Log initialization error but don't throw to prevent breaking site
			error_log("OMS initialization failed: " . $e->getMessage());
		}
	}

	/**
	 * Initialize the plugin.
	 */
	public function init()
	{
		try {
			$this->setupHooks();
			$this->logger->info('Plugin hooks initialized successfully');
		} catch (OMS_Exception $e) {
			$this->handleException($e, 'Failed to initialize plugin hooks');
		}
	}

	/**
	 * Set up WordPress hooks and filters.
	 *
	 * @throws OMS_Exception
	 */
	private function setupHooks()
	{
		if (!function_exists('register_activation_hook')) {
			throw new OMS_Exception('WordPress functions not available');
		}

		register_activation_hook(plugin_basename(__FILE__), array($this, 'runFullCleanup'));

		if (!wp_next_scheduled('oms_daily_cleanup')) {
			wp_schedule_event(time(), 'daily', 'oms_daily_cleanup');
		}

		add_action('oms_daily_cleanup', array($this, 'runFullCleanup'));
		add_action('added_post_meta', array($this, 'checkUploadedFile'), 10, 4);
		add_filter('upload_dir', array($this, 'sanitizeUploadPath'));
	}

	/**
	 * Load or compile malware patterns.
	 *
	 * @return array Compiled patterns
	 * @throws OMS_Exception
	 */
	private function loadOrCompilePatterns()
	{
		try {
			$patterns = array_merge(
				OMS_Config::OBFUSCATION_PATTERNS,
				OMS_Config::MALWARE_PATTERNS
			);

			$compiled = array();
			foreach ($patterns as $pattern) {
				if (@preg_match("#" . $pattern['pattern'] . "#i", '') === false) {
					$this->logger->warning("Invalid pattern skipped: " . $pattern['pattern']);
					continue;
				}
				$compiled[] = array(
					'pattern' => "#" . $pattern['pattern'] . "#i",
					'severity' => $pattern['severity'],
					'description' => $pattern['description']
				);
			}

			return $compiled;
		} catch (Exception $e) {
			throw new OMS_Exception("Failed to compile patterns: " . $e->getMessage());
		}
	}

	/**
	 * Perform a full cleanup of the site.
	 */
	public function runFullCleanup()
	{
		try {
			$this->logger->info('Starting full cleanup');
			$this->cleanupCoreFiles();
			$this->cleanupPlugins();
			$this->cleanupUploads();
			$this->cleanupQuarantine();
			$this->checkFilePermissions();
			$this->logger->info('Full cleanup completed successfully');
		} catch (Exception $e) {
			$this->handleException($e, 'Full cleanup failed');
		}
	}

	/**
	 * Cleanup WordPress core files.
	 */
	private function cleanupCoreFiles()
	{
		try {
			$checksums = $this->getCoreChecksums();
			foreach ($checksums as $file => $checksum) {
				$this->processCoreFile($file, $checksum);
			}
		} catch (Exception $e) {
			$this->handleException($e, 'Core file cleanup failed');
		}
	}

	private function processCoreFile($file, $checksum)
	{
		$filePath = OMS_Utils::sanitize_path(ABSPATH . $file);

		if (! OMS_Utils::is_path_safe($filePath)) {
			$this->logger->warning("Skipping unsafe path: $filePath");
			return;
		}

		if (! is_readable($filePath)) {
			$this->downloadCoreFile($file);
			return;
		}

		$fileHash = md5_file($filePath);
		if ($fileHash !== $checksum) {
			$this->logger->warning("Checksum mismatch for: $filePath");
			$this->downloadCoreFile($file);
		}
	}

	private function downloadCoreFile($file, $retry = 3)
	{
		$url         = sprintf('https://core.svn.wordpress.org/tags/%s/%s', get_bloginfo('version'), $file);
		$destination = ABSPATH . $file;

		while ($retry-- > 0) {
			if ($this->downloadFile($url, $destination)) {
				$this->logger->info('Downloaded core file', array('file' => $file));
				return true;
			}
			sleep(2); // Backoff delay
		}
		$this->logger->error('Failed to download core file after retries', array('file' => $file));
		return false;
	}

	/**
	 * Validate and sanitize uploaded files.
	 */
	public function checkUploadedFile($metaId, $postId, $metaKey, $metaValue)
	{
		if ($metaKey !== '_wp_attached_file') {
			return;
		}

		$uploadDir = wp_upload_dir();
		$filePath  = OMS_Utils::sanitize_path($uploadDir['basedir'] . '/' . $metaValue);

		if (! $this->securityPolicy->validateFile($filePath)['valid'] || $this->containsMalware($filePath)) {
			$this->quarantineFile($filePath);
			wp_delete_attachment($postId, true);
			$this->logger->warning("Malicious file quarantined: $filePath");
		}
	}

	/**
	 * Scan a file for malware patterns with improved obfuscation detection
	 */
	public function containsMalware($path)
	{
		try {
			if (! file_exists($path) || ! is_readable($path)) {
				$this->logger->warning('File not accessible', array('path' => $path));
				return true; // Treat inaccessible files as suspicious
			}

			// Check file size
			$filesize = @filesize($path);
			if ($filesize === false || $filesize === 0) {
				$this->logger->warning("Empty or zero-byte file detected", ['path' => $path]);
				return true; // Treat zero-byte files as suspicious
			}

			// First check for binary files that shouldn't contain PHP
			if ($this->isBinaryFile($path) && $this->containsPhpCode($path)) {
				$this->logger->error('PHP code found in binary file', array('path' => $path));
				return true;
			}

			// Scan with new obfuscation patterns first
			foreach (OMS_Config::OBFUSCATION_PATTERNS as $pattern) {
				if ($this->matchPattern($path, $pattern['pattern'])) {
					$this->logger->info(
						$pattern['severity'],
						"Detected {$pattern['description']}",
						array(
							'path'    => $path,
							'pattern' => $pattern['pattern'],
						)
					);
					return true;
				}
			}

			// Then check other malicious patterns
			$chunkSize = $this->calculateOptimalChunkSize();
			return $this->scanFileChunks($path, $chunkSize);
		} catch (Exception $e) {
			$this->handleException($e, "Error scanning file: $path");
			return true; // Treat exceptions as suspicious
		}
	}

	/**
	 * Check if a file is a binary file that shouldn't contain PHP code
	 */
	private function isBinaryFile($path)
	{
		$extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));
		return in_array($extension, array('jpg', 'jpeg', 'png', 'gif', 'pdf', 'zip'));
	}

	/**
	 * Check if a file contains PHP code
	 */
	private function containsPhpCode($path)
	{
		// Read first 1024 bytes to check for PHP signature
		$handle = fopen($path, 'rb');
		if ($handle === false) {
			return false;
		}

		$content = fread($handle, 1024);
		fclose($handle);

		return preg_match('/<\?php|<\?=|\xFF\xD8\xFF\xE0.*<\?php/s', $content) === 1;
	}

	/**
	 * Match a pattern against a file with proper error handling
	 */
	private function matchPattern($path, $pattern)
	{
		try {
			$content = file_get_contents($path);
			if ($content === false) {
				throw new Exception('Failed to read file contents');
			}
			return preg_match("/$pattern/i", $content) === 1;
		} catch (Exception $e) {
			$this->logger->error(
				'Pattern matching failed',
				array(
					'path'    => $path,
					'pattern' => $pattern,
					'error'   => $e->getMessage(),
				)
			);
			return false;
		}
	}

	/**
	 * Scan a file for malware patterns.
	 */
	public function scanFileChunks($filePath, $chunkSize)
	{
		try {
			if (! is_readable($filePath)) {
				throw new Exception("File not readable: $filePath");
			}

			$fileSize = filesize($filePath);
			if ($fileSize === 0) {
				$this->logger->warning("Zero-byte file detected: $filePath", 'warning');
				return false;
			}

			$handle = fopen($filePath, 'rb');
			if ($handle === false) {
				throw new Exception("Failed to open file: $filePath");
			}

			$matches = [];
			$offset = 0;
			$overlap = OMS_Config::SCAN_CONFIG['overlap_size']; // Overlap between chunks to catch patterns spanning chunks
			$suspiciousPatterns = $this->getMalwarePatterns();
			$startTime = microtime(true);
			$lastProgressUpdate = 0;

			while (! feof($handle)) {
				// Check for timeout
				if (microtime(true) - $startTime > OMS_Config::SECURITY_CONFIG['max_execution_time']) { // 5 minutes timeout
					throw new Exception("Scan timeout for file: $filePath");
				}

				// Throttle if needed
				if ($this->shouldThrottle()) {
					usleep(OMS_Config::SCAN_CONFIG['batch_pause'] * 1000); // Pause in milliseconds	
				}

				// Read chunk with overlap
				$chunk = fread($handle, $chunkSize + $overlap);
				if ($chunk === false) {
					throw new Exception("Failed to read chunk from file: $filePath");
				}

				// Update progress every 5%
				$progress = ($offset / $fileSize) * 100;
				if ($progress - $lastProgressUpdate >= 5) {
					$this->logger->info(sprintf("Scanning %s: %.1f%% complete", basename($filePath), $progress));
					$lastProgressUpdate = $progress;
				}

				// Check for malicious patterns
				foreach ($suspiciousPatterns as $pattern) {
					if (preg_match($pattern['pattern'], $chunk, $patternMatches, PREG_OFFSET_CAPTURE)) {
						$matches[] = [
							'pattern' => $pattern['pattern'],
							'description' => $pattern['description'],
							'offset' => $offset + $patternMatches[0][1],
							'match' => $patternMatches[0][0],
							'context' => $this->extractMatchContext($filePath, $pattern['pattern'])
						];

						$this->logger->warning(
							sprintf(
								"Found suspicious pattern in %s: %s at offset %d",
								basename($filePath),
								$pattern['description'],
								$offset + $patternMatches[0][1]
							),
							'warning'
						);
					}
				}

				// Move back by overlap amount unless at EOF
				if (! feof($handle)) {
					fseek($handle, $offset + $chunkSize - $overlap);
				}

				$offset += $chunkSize - $overlap;
			}

			fclose($handle);

			// Log completion
			$scanTime = microtime(true) - $startTime;
			$this->logger->info(
				sprintf(
					"Completed scanning %s in %.2f seconds. Found %d suspicious patterns.",
					basename($filePath),
					$scanTime,
					count($matches)
				),
				'info'
			);

			if (! empty($matches)) {
				// Store detailed results for admin review
				$this->logger->warning($filePath, $matches);
				return false; // File contains suspicious patterns
			}

			return true; // File is clean

		} catch (Exception $e) {
			$this->exception->handleException($e, "Error scanning file chunks: $filePath");
			return false;
		}
	}

	private function getMalwarePatterns()
	{
		return OMS_Config::MALWARE_PATTERNS;
	}

	private function getLogPath()
	{
		$logPath = OMS_Config::LOG_CONFIG['path'];
		if (! is_dir($logPath)) {
			wp_mkdir_p($logPath);
			$htaccess = $logPath . '/.htaccess';
			if (! file_exists($htaccess)) {
				file_put_contents($htaccess, 'Deny from all');
			}
		}
		return $logPath;
	}

	private function getQuarantinePath()
	{
		$quarantinePath = OMS_Config::QUARANTINE_CONFIG['path'];
		if (! is_dir($quarantinePath)) {
			wp_mkdir_p($quarantinePath);
			$htaccess = $quarantinePath . '/.htaccess';
			if (! file_exists($htaccess)) {
				file_put_contents($htaccess, 'Deny from all');
			}
		}
		return $quarantinePath;
	}

	private function isValidLogLevel($level)
	{
		return in_array(strtolower($level), OMS_Config::LOG_CONFIG['levels']);
	}

	private function enforceExecutionLimits()
	{
		@ini_set('max_execution_time', OMS_Config::SECURITY_CONFIG['max_execution_time']);
		@ini_set('memory_limit', OMS_Config::SECURITY_CONFIG['memory_limit']);
		@ini_set('max_input_time', OMS_Config::SECURITY_CONFIG['max_input_time']);
		@ini_set('max_input_vars', OMS_Config::SECURITY_CONFIG['max_input_vars']);
		@ini_set('post_max_size', OMS_Config::SECURITY_CONFIG['post_max_size']);
		@ini_set('upload_max_filesize', OMS_Config::SECURITY_CONFIG['upload_max_filesize']);
	}

	private function isExcludedPath($path)
	{
		$basename = basename($path);
		if (in_array($basename, OMS_Config::SCAN_CONFIG['excluded_files'])) {
			return true;
		}

		foreach (OMS_Config::SCAN_CONFIG['excluded_dirs'] as $dir) {
			if (strpos($path, "/$dir/") !== false) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Quarantine a file with fallback options and safety checks.
	 *
	 * @param string $path Path to the file to quarantine
	 * @return bool True if quarantine succeeded, false otherwise
	 */
	private function quarantineFile($path)
	{
		try {
			$quarantineDir = OMS_Config::QUARANTINE_CONFIG['path'];

			// Ensure quarantine directory exists and is writable
			if (! file_exists($quarantineDir)) {
				if (! @mkdir($quarantineDir, 0755, true)) {
					throw new Exception('Failed to create quarantine directory');
				}
			}

			if (! is_writable($quarantineDir)) {
				throw new Exception('Quarantine directory is not writable');
			}

			// Generate unique quarantine filename
			$timestamp      = date('Y-m-d_H-i-s');
			$uniqueId       = uniqid();
			$quarantinePath = sprintf(
				'%s/%s_%s_%s.quarantine',
				$quarantineDir,
				pathinfo($path, PATHINFO_FILENAME),
				$timestamp,
				$uniqueId
			);

			// Try primary quarantine method (rename)
			if (@rename($path, $quarantinePath)) {
				$this->logger->info(
					'File quarantined successfully',
					array(
						'original_path'   => $path,
						'quarantine_path' => $quarantinePath,
						'method'          => 'rename',
					)
				);
				return true;
			}

			// Fallback 1: Try copy and delete
			if (@copy($path, $quarantinePath)) {
				if (@unlink($path)) {
					$this->logger->info(
						'File quarantined using copy/delete',
						array(
							'original_path'   => $path,
							'quarantine_path' => $quarantinePath,
							'method'          => 'copy_delete',
						)
					);
					return true;
				}
				// If we can't delete the original, remove the quarantine copy
				@unlink($quarantinePath);
			}

			// Fallback 2: Try to make file inaccessible
			if ($this->makeFileInaccessible($path)) {
				$this->logger->warning(
					'File made inaccessible as quarantine fallback',
					array(
						'path'   => $path,
						'method' => 'chmod',
					)
				);
				return true;
			}

			throw new Exception('All quarantine methods failed');
		} catch (Exception $e) {
			$this->logger->error(
				'Quarantine failed',
				array(
					'path'  => $path,
					'error' => $e->getMessage(),
					'trace' => $e->getTraceAsString(),
				)
			);
			return false;
		}
	}

	/**
	 * Make a file inaccessible as a last resort.
	 *
	 * @param string $path Path to the file
	 * @return bool True if successful, false otherwise
	 */
	private function makeFileInaccessible($path)
	{
		// Try to remove all permissions
		if (@chmod($path, 0000)) {
			return true;
		}

		// Fallback: try to make file unreadable
		if (@chmod($path, 0333)) {
			return true;
		}

		return false;
	}

	/**
	 * Handle exceptions with proper logging and notifications.
	 *
	 * @param Exception $e The exception to handle
	 * @param string $context Additional context about where the exception occurred
	 */
	private function handleException(Exception $e, $context = '')
	{
		$severity = ($e instanceof OMS_Exception) ? 'HIGH' : 'CRITICAL';

		// Log the error with full context
		$this->logger->error(sprintf(
			"%s: %s\nStack trace: %s",
			$context,
			$e->getMessage(),
			$e->getTraceAsString()
		));

		// Notify admin based on severity
		if ($this->shouldNotifyAdmin($severity)) {
			$this->notifyAdmin($context, $e);
		}
	}

	/**
	 * Check if admin should be notified based on severity and settings.
	 *
	 * @param string $severity The severity level to check
	 * @return bool Whether admin should be notified
	 */
	private function shouldNotifyAdmin($severity)
	{
		$severityLevel = OMS_Config::SEVERITY_LEVELS[$severity] ?? OMS_Config::SEVERITY_LEVELS['LOW'];
		$thresholdLevel = OMS_Config::SEVERITY_LEVELS[OMS_Config::NOTIFICATION_THRESHOLD] ?? OMS_Config::SEVERITY_LEVELS['MEDIUM'];

		return $severityLevel >= $thresholdLevel;
	}

	/**
	 * Send notification to admin.
	 *
	 * @param string $context The context of the notification
	 * @param Exception $e The exception that triggered the notification
	 */
	private function notifyAdmin($context, Exception $e)
	{
		try {
			$admin_email = get_option('admin_email');
			if (!$admin_email) {
				throw new OMS_Exception('Admin email not configured');
			}

			$site_name = get_bloginfo('name');
			$subject = sprintf('Security Alert - %s', $site_name);

			$body = sprintf(
				"Security issue detected:\n\nContext: %s\nError ID: %s\nTime: %s\nMessage: %s\nStack trace: %s",
				$context,
				uniqid('OMS_ERR_'),
				current_time('mysql'),
				$e->getMessage(),
				$e->getTraceAsString()
			);

			wp_mail($admin_email, $subject, $body);
			$this->logger->info("Security notification sent to admin: $admin_email");
		} catch (Exception $notifyError) {
			$this->logger->error("Failed to send admin notification: " . $notifyError->getMessage());
		}
	}

	/**
	 * Cleanup plugins.
	 */
	public function cleanupPlugins()
	{
		$this->logger->info('Starting plugin cleanup');

		// Get all installed plugins
		$plugins = get_plugins();
		foreach ($plugins as $pluginPath => $pluginData) {
			$fullPath = WP_PLUGIN_DIR . '/' . $pluginPath;

			// Scan each plugin file
			$files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($fullPath));
			foreach ($files as $file) {
				if ($file->isFile()) {
					$path = $file->getPathname();

					// Check for malware patterns
					if ($this->containsMalware($path)) {
						$this->logger->warning("Malware detected in plugin file: $path");
						$this->quarantineFile($path);
					}
				}
			}
		}

		$this->logger->info('Plugin cleanup completed');
	}

	/**
	 * Cleanup uploads.
	 */
	public function cleanupUploads()
	{
		$this->logger->info('Starting uploads cleanup');

		$uploadsDir = WP_CONTENT_DIR . '/uploads';
		$files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($uploadsDir));
		foreach ($files as $file) {
			if ($file->isFile()) {
				$path = $file->getPathname();

				// Validate the file
				$validationResult = $this->validateFile($path);
				if (!$validationResult['valid']) {
					$this->logger->warning("Suspicious file detected: $path - Reason: {$validationResult['reason']}");
					$this->quarantineFile($path);
				}
			}
		}

		$this->logger->info('Uploads cleanup completed');
	}

	/**
	 * Validate file.
	 */
	public function validateFile($path)
	{
		$this->logger->info("Validating file: $path");

		try {
			// Check file size
			$filesize = filesize($path);
			if ($filesize > OMS_Config::SCAN_CONFIG['max_file_size']) {
				$this->logger->warning(sprintf(
					'File exceeds maximum size limit: %s (%d bytes)',
					$path,
					$filesize
				), 'warning');
				return false;
			}

			// Check file permissions
			$perms = fileperms($path) & 0777;
			if ($perms > OMS_Config::SCAN_CONFIG['allowed_permissions']['file']) {
				$this->logger->warning(sprintf(
					'File has unsafe permissions: %s (0%o)',
					$path,
					$perms
				), 'warning');
				return false;
			}

			// Skip excluded files
			$basename = basename($path);
			if (in_array($basename, OMS_Config::SCAN_CONFIG['excluded_files'])) {
				return true;
			}

			// Check for zero-byte files
			if ($filesize === 0) {
				$this->logger->warning("Zero-byte file detected: $path", 'warning');
				return false;
			}

			// Then check other malicious patterns
			$chunkSize = $this->calculateOptimalChunkSize();
			return $this->scanFileChunks($path, $chunkSize);
		} catch (Exception $e) {
			$this->handleException($e, "Error validating file: $path");
			return false;
		}
	}

	/**
	 * Cleanup quarantine.
	 */
	public function cleanupQuarantine()
	{
		try {
			$quarantinePath = OMS_Config::QUARANTINE_CONFIG['path'];
			$retentionDays = OMS_Config::QUARANTINE_CONFIG['retention_days'];
			$maxSize = OMS_Config::QUARANTINE_CONFIG['max_size'];

			if (!is_dir($quarantinePath)) {
				return;
			}

			$cutoffTime = strtotime("-{$retentionDays} days");
			$totalSize = 0;
			$files = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator($quarantinePath, RecursiveDirectoryIterator::SKIP_DOTS)
			);

			foreach ($files as $file) {
				if ($file->getMTime() < $cutoffTime) {
					unlink($file->getPathname());
					continue;
				}

				$totalSize += $file->getSize();
			}

			// If quarantine exceeds max size, remove oldest files
			if ($totalSize > $maxSize) {
				$files = iterator_to_array($files);
				usort($files, function ($a, $b) {
					return $a->getMTime() - $b->getMTime();
				});

				foreach ($files as $file) {
					if ($totalSize <= $maxSize) {
						break;
					}
					$totalSize -= $file->getSize();
					unlink($file->getPathname());
				}
			}
		} catch (Exception $e) {
			$this->handleException($e, 'Error cleaning up quarantine');
		}
	}

	/**
	 * Check file permissions.
	 */
	public function checkFilePermissions()
	{
		$this->logger->info('Starting file permissions check');

		$directories = [
			ABSPATH,
			WP_CONTENT_DIR,
			WP_CONTENT_DIR . '/uploads',
			WP_PLUGIN_DIR
		];

		$secureDirPerms = OMS_Config::SCAN_CONFIG['allowed_permissions']['dir'];
		$secureFilePerms = OMS_Config::SCAN_CONFIG['allowed_permissions']['file'];

		foreach ($directories as $directory) {
			$items = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($directory));
			foreach ($items as $item) {
				$path = $item->getPathname();

				$currentPerms = fileperms($path) & 0777;

				if ($item->isDir() && $currentPerms !== $secureDirPerms) {
					if (chmod($path, $secureDirPerms)) {
						$this->logger->info("Corrected directory permissions: $path");
					} else {
						$this->logger->error("Failed to correct directory permissions: $path");
					}
				} elseif ($item->isFile() && $currentPerms !== $secureFilePerms) {
					if (chmod($path, $secureFilePerms)) {
						$this->logger->info("Corrected file permissions: $path");
					} else {
						$this->logger->error("Failed to correct file permissions: $path");
					}
				}
			}
		}

		$this->logger->info('File permissions check completed');
	}

	/**
	 * Get core checksums.
	 */
	public function getCoreChecksums()
	{
		$this->logger->info('Retrieving WordPress core checksums');

		try {
			global $wp_version;
			$locale = get_locale();

			// Check cache first
			$cacheKey = "wp_checksums_{$wp_version}_{$locale}";
			$cachedChecksums = $this->cache->get($cacheKey);
			if ($cachedChecksums) {
				return $cachedChecksums;
			}

			// Construct API URL
			$url = sprintf(
				'https://api.wordpress.org/core/checksums/1.0/?version=%s&locale=%s',
				$wp_version,
				$locale
			);

			// Fetch checksums from WordPress API
			$response = wp_remote_get($url);
			if (is_wp_error($response)) {
				throw new Exception('Failed to fetch WordPress checksums: ' . $response->get_error_message());
			}

			$body = wp_remote_retrieve_body($response);
			$data = json_decode($body, true);

			if (empty($data) || !isset($data['checksums']) || !is_array($data['checksums'])) {
				throw new Exception('Invalid checksum data received from WordPress API');
			}

			// Cache the checksums
			$this->cache->set($cacheKey, $data['checksums'], 3600); // Cache for 1 hour

			$this->logger->info('Successfully retrieved WordPress core checksums');
			return $data['checksums'];
		} catch (Exception $e) {
			$this->logger->error('Error retrieving WordPress core checksums: ' . $e->getMessage());
			return array();
		}
	}

	/**
	 * Download file.
	 */
	public function downloadFile($url, $destination)
	{
		$this->logger->info("Downloading file from: $url to: $destination");

		try {
			// Validate URL
			if (!filter_var($url, FILTER_VALIDATE_URL)) {
				throw new Exception('Invalid URL provided');
			}

			// Validate destination directory
			$destDir = dirname($destination);
			if (!is_dir($destDir)) {
				if (!mkdir($destDir, 0755, true)) {
					throw new Exception("Failed to create destination directory: $destDir");
				}
			}

			if (!is_writable($destDir)) {
				throw new Exception("Destination directory is not writable: $destDir");
			}

			// Download file using WordPress functions
			$response = wp_remote_get($url, array(
				'timeout' => 300,
				'stream' => true,
				'filename' => $destination
			));

			if (is_wp_error($response)) {
				throw new Exception('Download failed: ' . $response->get_error_message());
			}

			// Verify file was downloaded
			if (!file_exists($destination)) {
				throw new Exception('File download failed: File not found at destination');
			}

			// Verify file size
			$fileSize = filesize($destination);
			if ($fileSize === 0) {
				unlink($destination);
				throw new Exception('Downloaded file is empty');
			}

			$this->logger->info("File downloaded successfully: $destination");
			return true;
		} catch (Exception $e) {
			$this->logger->error('File download error: ' . $e->getMessage());
			if (file_exists($destination)) {
				unlink($destination);
			}
			return false;
		}
	}

	/**
	 * Critical error handler.
	 */
	public function critical($message)
	{
		// Log critical error with timestamp and backtrace
		$timestamp = current_time('mysql');
		$backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 3);
		$caller = isset($backtrace[1]) ? $backtrace[1]['function'] : 'unknown';

		$logMessage = sprintf(
			'[%s] CRITICAL ERROR in %s: %s',
			$timestamp,
			$caller,
			$message
		);

		// Log to WordPress error log
		error_log($logMessage);

		// Log to our custom log
		$this->logger->error($logMessage);

		// Notify admin if enabled and critical errors notifications are enabled
		if (
			self::OMS_NOTIFY_ADMIN['enabled'] &&
			self::OMS_NOTIFY_ADMIN['notification_types']['critical_errors']
		) {
			$admin_email = get_option('admin_email');
			$site_name = get_bloginfo('name');

			$subject = 'Critical Security Alert - ' . get_bloginfo('name');
			$body = sprintf(
				"Critical security issue detected:\n\nError ID: %s\nTime: %s\nMessage: %s\n%s",
				uniqid('OMS_ERR_'),
				$timestamp,
				$message,
				self::OMS_NOTIFY_ADMIN['include_context'] ? "\nContext: " . $caller : ''
			);

			wp_mail($admin_email, $subject, $body);

			// Store in database for audit trail
			if (function_exists('update_option')) {
				$audit_log = get_option('oms_security_audit_log', array());
				$audit_log[] = array(
					'timestamp' => $timestamp,
					'level' => 'CRITICAL',
					'message' => $message,
					'caller' => $caller
				);

				// Keep only last 100 entries
				if (count($audit_log) > 100) {
					$audit_log = array_slice($audit_log, -100);
				}

				update_option('oms_security_audit_log', $audit_log);
			}
		}

		// Perform cleanup if necessary @TODO CLeanup of WHAT?
		if (isset($context['cleanup_required']) && $context['cleanup_required']) {
			$this->runFullCleanup($context);
		}
	}

	/**
	 * Calculate optimal chunk size.
	 */
	public function calculateOptimalChunkSize()
	{
		try {
			// Get PHP memory limit
			$memoryLimit = $this->getMemoryLimit();

			// Get available memory
			$availableMemory = $this->getAvailableMemory();

			// Get disk space
			$availableDiskSpace = disk_free_space(ABSPATH);

			// Calculate base chunk size (20% of available memory)
			$baseChunkSize = (int)($availableMemory * 0.2);

			// Apply constraints
			$minChunkSize = 1024 * 1024;      // 1MB minimum
			$maxChunkSize = 5 * 1024 * 1024;  // 5MB maximum

			// Adjust based on available disk space
			if ($availableDiskSpace < $baseChunkSize * 10) {
				$baseChunkSize = (int)($availableDiskSpace * 0.1);
			}

			// Ensure chunk size is within bounds
			$chunkSize = max($minChunkSize, min($baseChunkSize, $maxChunkSize));

			$this->logger->info(sprintf(
				'Calculated optimal chunk size: %d bytes (Memory: %d, Disk: %d)',
				$chunkSize,
				$availableMemory,
				$availableDiskSpace
			));

			return $chunkSize;
		} catch (Exception $e) {
			$this->logger->error('Error calculating chunk size: ' . $e->getMessage());
			return 1024 * 1024; // Return 1MB as safe default
		}
	}

	private function getMemoryLimit()
	{
		$memoryLimit = ini_get('memory_limit');
		if ($memoryLimit === '-1') {
			return PHP_INT_MAX;
		}

		if (preg_match('/^(\d+)(.)$/', $memoryLimit, $matches)) {
			$value = (int)$matches[1];
			$unit = strtolower($matches[2]);
			switch ($unit) {
				case 'g':
					$value *= 1024;
				case 'm':
					$value *= 1024;
				case 'k':
					$value *= 1024;
			}
			return $value;
		}

		return 128 * 1024 * 1024; // 128MB default
	}

	private function getAvailableMemory()
	{
		$memoryLimit = $this->getMemoryLimit();
		$memoryUsage = memory_get_usage(true);
		$availableMemory = $memoryLimit - $memoryUsage;

		return max(0, $availableMemory);
	}

	/**
	 * Check if should throttle.
	 */
	public function shouldThrottle()
	{
		try {
			// Check if rate limiting is enabled
			if (!defined('OMS_RATE_LIMIT_ENABLED')) {
				define('OMS_RATE_LIMIT_ENABLED', true);
			}

			if (!OMS_RATE_LIMIT_ENABLED) {
				return false;
			}

			// Check server load
			if (function_exists('sys_getloadavg')) {
				$load = sys_getloadavg();
				$maxLoad = OMS_Config::RATE_LIMIT_CONFIG['max_cpu_load'];

				if ($load[0] > $maxLoad) {
					$this->logger->warning(sprintf('High server load detected: %.2f', $load[0]));
					return true;
				}
			}

			// Check memory usage
			$memoryUsage = memory_get_usage(true);
			$memoryLimit = $this->getMemoryLimit();
			$maxMemoryPercent = OMS_Config::RATE_LIMIT_CONFIG['max_memory_percent'];

			if (($memoryUsage / $memoryLimit) * 100 > $maxMemoryPercent) {
				$this->logger->warning(sprintf(
					'High memory usage detected: %.2f%%',
					($memoryUsage / $memoryLimit) * 100
				));
				return true;
			}

			// Check request rate
			$requestKey = 'oms_request_count_' . date('Y-m-d-H');
			$requestCount = (int)get_transient($requestKey);
			$maxRequests = OMS_Config::RATE_LIMIT_CONFIG['requests_per_hour'];

			if ($requestCount > $maxRequests) {
				$this->logger->warning('Request limit exceeded for current hour');
				return true;
			}

			// Increment request count
			set_transient($requestKey, $requestCount + 1, HOUR_IN_SECONDS);

			// Check peak hours
			$hour = (int)current_time('G');
			$peakStart = OMS_Config::RATE_LIMIT_CONFIG['peak_hour_start'];
			$peakEnd = OMS_Config::RATE_LIMIT_CONFIG['peak_hour_end'];

			if ($hour >= $peakStart && $hour <= $peakEnd) {
				// During peak hours, be more conservative
				if ($load[0] > $maxLoad * 0.8) {
					$this->logger->info('Throttling during peak hours');
					return true;
				}
			}

			return false;
		} catch (Exception $e) {
			$this->logger->error('Error in throttle check: ' . $e->getMessage());
			return true; // Throttle on error to be safe
		}
	}

	/**
	 * Extract match context.
	 */
	public function extractMatchContext($file, $pattern)
	{
		$this->logger->info("Extracting context for pattern matches in: $file");

		try {
			if (!file_exists($file) || !is_readable($file)) {
				throw new Exception("File not accessible: $file");
			}

			// Read file content in chunks to handle large files
			$handle = fopen($file, 'r');
			if ($handle === false) {
				throw new Exception("Failed to open file: $file");
			}

			$matches = array();
			$lineNumber = 0;
			$contextLines = 3; // Number of lines before and after match
			$buffer = array();

			// Read file line by line
			while (!feof($handle)) {
				$line = fgets($handle);
				if ($line === false) {
					break;
				}

				$lineNumber++;

				// Keep a rolling buffer of recent lines
				$buffer[] = array(
					'number' => $lineNumber,
					'content' => rtrim($line)
				);

				// Keep only necessary lines in buffer
				if (count($buffer) > $contextLines * 2 + 1) {
					array_shift($buffer);
				}

				// Check for pattern match
				if (preg_match($pattern, $line)) {
					// Calculate context range
					$contextStart = max(0, count($buffer) - $contextLines - 1);
					$context = array_slice($buffer, $contextStart);

					// Store match with context
					$matches[] = array(
						'line' => $lineNumber,
						'context' => $context,
						'match' => trim($line)
					);

					// Log the match
					$this->logger->warning(sprintf(
						'Found match in %s on line %d: %s',
						$file,
						$lineNumber,
						substr(trim($line), 0, 100) . (strlen($line) > 100 ? '...' : '')
					));
				}
			}

			fclose($handle);

			// Format the output
			$output = array();
			foreach ($matches as $match) {
				$contextStr = "Match on line {$match['line']}:\n";
				foreach ($match['context'] as $contextLine) {
					$prefix = $contextLine['number'] === $match['line'] ? '>' : ' ';
					$contextStr .= sprintf(
						"%s %4d: %s\n",
						$prefix,
						$contextLine['number'],
						$this->sanitizeOutput($contextLine['content'])
					);
				}
				$output[] = $contextStr;
			}

			return array(
				'file' => $file,
				'pattern' => $pattern,
				'matches' => count($matches),
				'contexts' => $output
			);
		} catch (Exception $e) {
			$this->logger->error('Error extracting match context: ' . $e->getMessage());
			return array(
				'file' => $file,
				'pattern' => $pattern,
				'matches' => 0,
				'contexts' => array(),
				'error' => $e->getMessage()
			);
		}
	}

	private function sanitizeOutput($content)
	{
		// Remove null bytes and control characters
		$content = str_replace("\0", '', $content);
		$content = preg_replace('/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/', '', $content);

		// Encode special characters for safe display
		return htmlspecialchars($content, ENT_QUOTES, 'UTF-8');
	}
}
