<?php
/**
 * Main plugin class for malware scanner
 *
 * @package ObfuscatedMalwareScanner
 */

// If this file is called directly, abort.
if ( ! defined( 'ABSPATH' ) ) {
	die( 'Direct access is not allowed.' );
}

require_once __DIR__ . '/class-oms-config.php';
require_once __DIR__ . '/class-oms-logger.php';
require_once __DIR__ . '/class-oms-utils.php';
require_once __DIR__ . '/class-oms-exception.php';

/**
 * Main plugin class.
 *
 * @phpcs:ignore WordPress.NamingConventions.PrefixAllGlobals.NonPrefixedClassFound -- Main plugin class name.
 */
class Obfuscated_Malware_Scanner {
	/**
	 * Logger instance.
	 *
	 * @var OMS_Logger
	 */
	private $logger;





	const RATE_LIMITS       = 5; // Define RATE_LIMITS constant.
	const BACKDOOR_PATTERNS = array(); // Define BACKDOOR_PATTERNS constant.
	/**
	 * Admin notification settings
	 */
	const OMS_NOTIFY_ADMIN = array(
		'enabled'                    => true,
		'severity_threshold'         => 'warning',  // Minimum severity level to notify.
		'batch_interval'             => 3600,      // Seconds between notification batches.
		'max_notifications_per_hour' => 10,      // Prevent notification flood.
		'include_context'            => true,       // Include surrounding code context.
		'notification_types'         => array(
			'malware_detected'   => true,
			'zero_byte_files'    => true,
			'permission_changes' => true,
			'critical_errors'    => true,
			'quarantine_actions' => true,
		),
	);

	/**
	 * Cache instance.
	 *
	 * @var OMS_Cache
	 */
	private $cache;

	/**
	 * Rate limiter instance.
	 *
	 * @var OMS_Rate_Limiter
	 */
	private $rate_limiter;

	/**
	 * Security policy instance.
	 *
	 * @var OMS_File_Security_Policy
	 */
	private $security_policy;



	/**
	 * Database scanner instance.
	 *
	 * @var OMS_Database_Scanner
	 */
	private $database_scanner;

	/**
	 * Quarantine manager instance.
	 *
	 * @var OMS_Quarantine_Manager
	 */
	private $quarantine_manager;



	/**
	 * Filesystem instance.
	 *
	 * @var OMS_Filesystem
	 */
	private $filesystem;

	/**
	 * Core integrity checker instance.
	 *
	 * @var OMS_Core_Integrity_Checker
	 */
	private $core_integrity_checker;

	/**
	 * Plugin directory path.
	 *
	 * @var string
	 */
	private $plugin_dir;

	/**
	 * Theme directory path.
	 *
	 * @var string
	 */
	private $theme_dir;

	/**
	 * Uploads directory path.
	 *
	 * @var string
	 */
	private $uploads_dir;

	/**
	 * API instance.
	 *
	 * @var OMS_API
	 */
	private $api;

	/**
	 * Constructor.
	 */
	public function __construct() {
		try {
			$this->logger                 = new OMS_Logger();
			$this->cache                  = new OMS_Cache();
			$this->rate_limiter           = new OMS_Rate_Limiter( array( 'default' => self::RATE_LIMITS ), $this->logger );
			$this->filesystem             = new OMS_Filesystem();
			$this->security_policy        = new OMS_File_Security_Policy( $this->filesystem );
			$this->quarantine_manager     = new OMS_Quarantine_Manager( $this->logger );
			$this->database_scanner       = new OMS_Database_Scanner( $this->logger, $this->cache );
			$this->core_integrity_checker = new OMS_Core_Integrity_Checker( $this->logger );
			$this->plugin_dir             = defined( 'WP_PLUGIN_DIR' ) ? WP_PLUGIN_DIR : '';
			$this->theme_dir              = defined( 'WP_CONTENT_DIR' ) ? WP_CONTENT_DIR . '/themes' : '';
			$this->uploads_dir            = defined( 'WP_CONTENT_DIR' ) ? WP_CONTENT_DIR . '/uploads' : '';
			$this->api                    = new OMS_API( $this->logger, $this );

			$this->logger->info( 'Scanner initialized successfully' );
		} catch ( OMS_Exception $e ) {
			// Log initialization error but don't throw to prevent breaking site.
			if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
				error_log( 'OMS initialization failed: ' . esc_html( $e->getMessage() ) ); // phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_error_log -- Debug logging only when WP_DEBUG is enabled.
			}
			// Fallback to basic patterns if compilation fails.

		}
	}

	/**
	 * Initialize the plugin.
	 */
	public function init() {
		try {
			$this->setup_hooks();
			$this->api->init();
		} catch ( OMS_Exception $e ) {
			$this->logger->error( 'Failed to initialize hooks: ' . $e->getMessage() );
		}
	}

	/**
	 * Set up WordPress hooks and filters.
	 *
	 * @throws OMS_Exception If WordPress functions are not available.
	 */
	private function setup_hooks() {
		if ( ! function_exists( 'register_activation_hook' ) ) {
			throw new OMS_Exception( 'WordPress functions not available' );
		}

		// Note: Activation hook is registered in the main plugin file (obfuscated-malware-scanner.php)
		// to ensure proper plugin initialization order.

		if ( ! wp_next_scheduled( 'oms_daily_cleanup' ) ) {
			wp_schedule_event( time(), 'daily', 'oms_daily_cleanup' );
		}

		add_action( 'oms_daily_cleanup', array( $this, 'run_full_cleanup' ) );
		add_action( 'added_post_meta', array( $this, 'check_uploaded_file' ), 10, 4 );
		add_filter( 'upload_dir', array( $this, 'sanitize_upload_path' ) );
	}



	/**
	 * Run daily security scan
	 *
	 * Scans all areas for threats and quarantines suspicious files.
	 * Database issues are reported but NOT auto-cleaned (requires manual trigger).
	 */
	public function run_full_cleanup() {
		try {
			$this->logger->info( 'Starting daily security scan' );
			$this->cleanup_core_files();
			$this->cleanup_plugins();
			$this->cleanup_themes();
			$this->cleanup_uploads();
			$this->cleanup_quarantine();
			$this->check_file_permissions();
			$this->scan_database(); // Scan only - no auto-cleanup.
			$this->logger->info( 'Daily security scan completed' );
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Daily security scan failed' );
		}
	}

	/**
	 * Verified core files.
	 *
	 * @var array
	 */
	private $verified_core_files = array();

	/**
	 * Cleanup WordPress core files.
	 */
	private function cleanup_core_files() {
		try {
			$this->logger->info( 'Verifying core files...' );
			$results = $this->core_integrity_checker->verify_core_files();

			if ( isset( $results['error'] ) ) {
				$this->logger->error( 'Core verification failed: ' . $results['error'] );
				return;
			}

			// Cache verified files for exclusion in other scans.
			$this->verified_core_files = $results['safe'];
			$this->logger->info( sprintf( 'Verified %d core files', count( $this->verified_core_files ) ) );

			foreach ( $results['modified'] as $file ) {
				$this->logger->warning( 'Core file mismatch: ' . $file );
				// We report but do not auto-repair yet to avoid breaking custom setups.
			}

			foreach ( $results['missing'] as $file ) {
				$this->logger->warning( 'Missing core file: ' . $file );
				// We report but do not auto-repair yet.
			}
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Core file cleanup failed' );
		}
	}


	/**
	 * Sanitize upload directory paths.
	 *
	 * This method filters the upload_dir array to ensure all paths are sanitized
	 * and safe before WordPress uses them. It prevents path traversal attacks
	 * while allowing normal WordPress upload directory operations.
	 *
	 * @param array $upload_dir Array of upload directory data with keys:
	 *                          'path', 'url', 'subdir', 'basedir', 'baseurl', 'error'.
	 * @return array Modified upload directory array with sanitized paths.
	 */
	public function sanitize_upload_path( $upload_dir ) {
		// Return early if not an array or if WordPress already flagged an error.
		if ( ! is_array( $upload_dir ) || ( isset( $upload_dir['error'] ) && $upload_dir['error'] ) ) {
			return $upload_dir;
		}

		// Sanitize path values to prevent path traversal attacks.
		$keys_to_sanitize = array( 'path', 'basedir' );
		foreach ( $keys_to_sanitize as $key ) {
			if ( isset( $upload_dir[ $key ] ) && is_string( $upload_dir[ $key ] ) ) {
				// Normalize the path first.
				$normalized_path = wp_normalize_path( $upload_dir[ $key ] );

				// Check for path traversal attacks using OMS_Utils::is_path_safe.
				// We use is_path_safe directly instead of sanitize_path to avoid
				// throwing exceptions on normal upload directories (which may have
				// executable bits that are acceptable for directories).
				if ( ! OMS_Utils::is_path_safe( $normalized_path ) ) {
					// Invalid path detected - log and set error message.
					$this->logger->warning( 'Invalid upload path detected (path traversal): ' . esc_html( $upload_dir[ $key ] ) );
					// WordPress expects 'error' to be a string message, not a boolean.
					$upload_dir['error'] = sprintf(
						/* translators: %s: The upload path that was detected as unsafe */
						__( 'Invalid upload path detected: %s', 'obfuscated-malware-scanner' ),
						esc_html( $upload_dir[ $key ] )
					);
					return $upload_dir;
				}

				// Use normalized path.
				$upload_dir[ $key ] = $normalized_path;
			}
		}

		return $upload_dir;
	}

	/**
	 * Validate and sanitize uploaded files.
	 *
	 * @param int    $meta_id Meta ID.
	 * @param int    $post_id Post ID.
	 * @param string $meta_key Meta key.
	 * @param mixed  $meta_value Meta value.
	 */
	public function check_uploaded_file( $meta_id, $post_id, $meta_key, $meta_value ) {
		if ( '_wp_attached_file' !== $meta_key ) {
			return;
		}

		$upload_dir = wp_upload_dir();
		if ( ! isset( $upload_dir['basedir'] ) || ! is_string( $upload_dir['basedir'] ) ) {
			$this->logger->error( 'Invalid upload directory configuration: basedir not found' );
			return;
		}

		$file_path = null;
		try {
			$file_path = OMS_Utils::sanitize_path( $upload_dir['basedir'] . '/' . $meta_value );

			$validation_result = $this->security_policy->validate_file( $file_path );
			$is_valid          = is_array( $validation_result ) && isset( $validation_result['valid'] ) && $validation_result['valid'];

			if ( ! $is_valid || $this->contains_malware( $file_path ) ) {
				$this->quarantine_file( $file_path );
				wp_delete_attachment( $post_id, true );
				$this->logger->warning( 'Malicious file quarantined: ' . esc_html( $file_path ) );
			}
		} catch ( InvalidArgumentException $e ) {
			$this->logger->error( 'Invalid file path in upload check: ' . $e->getMessage() );
			// Fail safe: if path is invalid, we can't trust it.
		} catch ( OMS_Security_Exception $e ) {
			$this->logger->error( 'Security violation in upload check: ' . $e->getMessage() );
			// Fail safe: quarantine if possible.
			if ( null !== $file_path ) {
				$this->quarantine_file( $file_path );
			}
		} catch ( Throwable $e ) {
			$this->logger->error( 'Unexpected error in upload check: ' . $e->getMessage() );
			// Fail safe logic.
			if ( null !== $file_path ) {
				$this->quarantine_file( $file_path );
			}
		}
	}

	/**
	 * Scan a file for malware patterns with improved obfuscation detection.
	 *
	 * @param string $path File path.
	 * @return bool True if malware detected.
	 */
	public function contains_malware( $path ) {
		try {
			if ( ! file_exists( $path ) || ! is_readable( $path ) ) {
				$this->logger->warning( sprintf( 'File not accessible: %s', esc_html( $path ) ) );
				return true; // Treat inaccessible files as suspicious.
			}

			// Check file size.
			$filesize = filesize( $path );
			if ( false === $filesize ) {
				$this->logger->warning( sprintf( 'Failed to get file size: %s', esc_html( $path ) ) );
				return true; // Treat files with unreadable size as suspicious.
			}
			if ( 0 === $filesize ) {
				$this->logger->warning( sprintf( 'Empty or zero-byte file detected: %s', esc_html( $path ) ) );
				return true; // Treat zero-byte files as suspicious.
			}

			// First check for binary files that shouldn't contain PHP.
			if ( $this->is_binary_file( $path ) && $this->contains_php_code( $path ) ) {
				$this->logger->error( sprintf( 'PHP code found in binary file: %s', esc_html( $path ) ) );
				return true;
			}

			// Scan with new obfuscation patterns first.
			foreach ( OMS_Config::OBFUSCATION_PATTERNS as $pattern ) {
				if ( $this->match_pattern( $path, $pattern['pattern'] ) ) {
					$description = $pattern['description'];
					$this->logger->info(
						sprintf(
							'Detected %s - Path: %s, Pattern: %s',
							esc_html( $description ),
							esc_html( $path ),
							esc_html( $pattern['pattern'] )
						)
					);
					return true;
				}
			}

			// Then check other malicious patterns.
			$chunk_size = $this->calculate_optimal_chunk_size();
			return $this->scan_file_chunks( $path, $chunk_size );
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Error scanning file: ' . esc_html( $path ) );
			return true; // Treat exceptions as suspicious.
		}
	}

	/**
	 * Check if a file is a binary file that shouldn't contain PHP code.
	 *
	 * @param string $path File path.
	 * @return bool True if binary file.
	 */
	private function is_binary_file( $path ) {
		$extension = strtolower( pathinfo( $path, PATHINFO_EXTENSION ) );
		return in_array( $extension, array( 'jpg', 'jpeg', 'png', 'gif', 'pdf', 'zip' ), true );
	}

	/**
	 * Check if a file contains PHP code.
	 *
	 * @param string $path File path.
	 * @return bool True if PHP code found.
	 */
	private function contains_php_code( $path ) {
		// Read first 1024 bytes to check for PHP signature.
		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fopen -- Binary file reading required for security scanning.
		$handle = fopen( $path, 'rb' );
		if ( false === $handle ) {
			return false;
		}

		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fread -- Binary file reading required for security scanning.
		$content = fread( $handle, 1024 );
		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fclose -- Binary file reading required for security scanning.
		fclose( $handle );

		return 1 === preg_match( '/<\?php|<\?=|\xFF\xD8\xFF\xE0.*<\?php/s', $content );
	}

	/**
	 * Match a pattern against a file with proper error handling.
	 *
	 * @param string $path File path.
	 * @param string $pattern Pattern to match.
	 * @return bool True if pattern matches.
	 * @throws Exception If file cannot be read.
	 */
	private function match_pattern( $path, $pattern ) {
		try {
			$content = file_get_contents( $path );
			if ( false === $content ) {
				throw new Exception( 'Failed to read file contents' );
			}
			return 1 === preg_match( "/$pattern/i", $content );
		} catch ( Exception $e ) {
			$this->logger->error(
				sprintf(
					'Pattern matching failed - Path: %s, Pattern: %s, Error: %s',
					esc_html( $path ),
					esc_html( $pattern ),
					esc_html( $e->getMessage() )
				)
			);
			return false;
		}
	}

	/**
	 * Scan a file for malware patterns.
	 *
	 * @param string $file_path File path.
	 * @param int    $chunk_size Chunk size.
	 * @return bool True if malware found.
	 * @throws Exception If file cannot be read.
	 */
	public function scan_file_chunks( $file_path, $chunk_size ) {
		if ( ! is_readable( $file_path ) ) {
			throw new Exception( 'File not readable: ' . esc_html( $file_path ) );
		}

		$file_size = filesize( $file_path );
		if ( 0 === $file_size ) {
			$this->logger->warning( sprintf( 'Zero-byte file detected: %s', esc_html( $file_path ) ) );
			return false; // Zero byte files are not malware (but might be suspicious elsewhere).
		}

		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fopen -- Binary file reading required for chunked malware scanning.
		$handle = fopen( $file_path, 'rb' );
		if ( false === $handle ) {
			throw new Exception( 'Failed to open file: ' . esc_html( $file_path ) );
		}

		try {
			$matches              = array();
			$offset               = 0;
			$overlap              = OMS_Config::SCAN_CONFIG['overlap_size']; // Overlap between chunks to catch patterns spanning chunks.
			$suspicious_patterns  = $this->get_malware_patterns();
			$start_time           = microtime( true );
			$last_progress_update = 0;

			while ( ! feof( $handle ) ) {
				// Check for timeout.
				if ( microtime( true ) - $start_time > OMS_Config::SECURITY_CONFIG['max_execution_time'] ) { // 5 minutes timeout.
					throw new Exception( 'Scan timeout for file: ' . esc_html( $file_path ) );
				}

				// Throttle if needed.
				if ( $this->rate_limiter->should_throttle() ) {
					usleep( OMS_Config::SCAN_CONFIG['batch_pause'] * 1000 ); // Pause in milliseconds.
				}

				// Read chunk with overlap.
				// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fread -- Binary file reading required for chunked malware scanning.
				$chunk = fread( $handle, $chunk_size + $overlap );
				if ( false === $chunk ) {
					throw new Exception( 'Failed to read chunk from file: ' . esc_html( $file_path ) );
				}

				// Update progress every 5%.
				$progress = ( $offset / $file_size ) * 100;
				if ( $progress - $last_progress_update >= 5 ) {
					$this->logger->info( sprintf( 'Scanning %s: %.1f%% complete', esc_html( basename( $file_path ) ), $progress ) );
					$last_progress_update = $progress;
				}

				// Check for malicious patterns.
				foreach ( $suspicious_patterns as $pattern ) {
					if ( preg_match( $pattern['pattern'], $chunk, $pattern_matches, PREG_OFFSET_CAPTURE ) ) {
						$description = $pattern['description'];
						$matches[]   = array(
							'pattern'     => $pattern['pattern'],
							'description' => $description,
							'offset'      => $offset + $pattern_matches[0][1],
							'match'       => $pattern_matches[0][0],
							'context'     => $this->extract_match_context( $file_path, $pattern['pattern'] ),
						);

						$this->logger->warning(
							sprintf(
								'Found suspicious pattern in %s: %s at offset %d',
								esc_html( basename( $file_path ) ),
								esc_html( $description ),
								$offset + $pattern_matches[0][1]
							)
						);
					}
				}

				// Move back by overlap amount unless at EOF.
				if ( ! feof( $handle ) ) {
					fseek( $handle, $offset + $chunk_size - $overlap );
				}

				$offset += $chunk_size - $overlap;
			}

			// Log completion.
			$scan_time = microtime( true ) - $start_time;
			$this->logger->info(
				sprintf(
					'Completed scanning %s in %.2f seconds. Found %d suspicious patterns.',
					esc_html( basename( $file_path ) ),
					$scan_time,
					count( $matches )
				)
			);

			if ( ! empty( $matches ) ) {
				// Store detailed results for admin review.
				$matches_json = wp_json_encode( $matches );
				$matches_str  = false !== $matches_json ? $matches_json : '[]';
				$this->logger->warning( sprintf( 'Suspicious patterns found in %s: %s', esc_html( $file_path ), esc_html( $matches_str ) ) );
				return true; // File contains suspicious patterns.
			}

			return false; // File is clean.

		} finally {
			// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fclose -- Binary file reading required for chunked malware scanning.
			if ( is_resource( $handle ) ) {
				fclose( $handle );
			}
		}
	}

	/**
	 * Get malware patterns.
	 *
	 * @return array Malware patterns.
	 */
	private function get_malware_patterns() {
		return OMS_Config::MALWARE_PATTERNS;
	}

	/**
	 * Get log path.
	 *
	 * @return string Log path.
	 */
	public function get_log_path() {
		$log_path = OMS_Config::LOG_CONFIG['path'];
		$this->ensure_directory_secure( $log_path );
		return $log_path;
	}



	/**
	 * Ensure directory exists and is secure.
	 *
	 * @param string $path Directory path.
	 */
	private function ensure_directory_secure( $path ) {
		if ( ! is_dir( $path ) ) {
			wp_mkdir_p( $path );
			$htaccess = $path . '/.htaccess';
			if ( ! file_exists( $htaccess ) ) {
				$result = file_put_contents(
					$htaccess,
					'Order deny,allow
Deny from all
Require all denied
'
				);
				if ( false === $result ) {
					$this->logger->error( sprintf( 'Failed to create .htaccess file for directory: %s', esc_html( $htaccess ) ) );
				}
			}
		}
	}







	/**
	 * Quarantine a file with fallback options and safety checks.
	 *
	 * @param string $file_path Path to the file to quarantine.
	 * @return bool True if quarantine succeeded, false otherwise.
	 * @throws Exception If quarantine fails.
	 */
	public function quarantine_file( $file_path ) {
		// Safety check: Never quarantine core files.
		if ( $this->is_core_file( $file_path ) ) {
			$this->logger->error( 'Attempted to quarantine core file: ' . esc_html( $file_path ) );
			return false;
		}

		return $this->quarantine_manager->quarantine_file( $file_path );
	}



	/**
	 * Handle exceptions with proper logging and notifications.
	 *
	 * @param Exception $e The exception to handle.
	 * @param string    $context Additional context about where the exception occurred.
	 */
	private function handle_exception( Exception $e, $context = '' ) {
		$severity = ( $e instanceof OMS_Exception ) ? 'HIGH' : 'CRITICAL';

		// Log the error with full context.
		$this->logger->error(
			sprintf(
				'%s: %s\nStack trace: %s',
				esc_html( $context ),
				esc_html( $e->getMessage() ),
				esc_html( $e->getTraceAsString() )
			)
		);

		// Notify admin based on severity.
		if ( $this->should_notify_admin( $severity ) ) {
			$this->notify_admin( $context, $e );
		}
	}

	/**
	 * Check if admin should be notified based on severity and settings.
	 *
	 * @param string $severity The severity level to check.
	 * @return bool Whether admin should be notified.
	 */
	private function should_notify_admin( $severity ) {
		$severity_level  = OMS_Config::SEVERITY_LEVELS[ $severity ] ?? OMS_Config::SEVERITY_LEVELS['LOW'];
		$threshold_level = OMS_Config::SEVERITY_LEVELS[ OMS_Config::NOTIFICATION_THRESHOLD ];

		return $severity_level >= $threshold_level;
	}

	/**
	 * Send notification to admin.
	 *
	 * @param string    $context The context of the notification.
	 * @param Exception $e The exception that triggered the notification.
	 * @throws OMS_Exception If admin email is not configured.
	 */
	private function notify_admin( $context, Exception $e ) {
		try {
			$admin_email = get_option( 'admin_email' );
			if ( ! $admin_email ) {
				throw new OMS_Exception( 'Admin email not configured' );
			}

			$site_name = get_bloginfo( 'name' );
			$subject   = sprintf( 'Security Alert - %s', esc_html( $site_name ) );

			$body = sprintf(
				"Security issue detected:\n\nContext: %s\nError ID: %s\nTime: %s\nMessage: %s\nStack trace: %s",
				esc_html( $context ),
				esc_html( uniqid( 'OMS_ERR_' ) ),
				esc_html( current_time( 'mysql' ) ),
				esc_html( $e->getMessage() ),
				esc_html( $e->getTraceAsString() )
			);

			wp_mail( $admin_email, $subject, $body );
			$this->logger->info( 'Security notification sent to admin: ' . esc_html( $admin_email ) );
		} catch ( Exception $notify_error ) {
			$this->logger->error( 'Failed to send admin notification: ' . esc_html( $notify_error->getMessage() ) );
		}
	}

	/**
	 * Cleanup plugins.
	 */
	public function cleanup_plugins() {
		$this->scan_directory_for_cleanup( $this->plugin_dir, 'plugin' );
	}

	/**
	 * Cleanup themes.
	 */
	public function cleanup_themes() {
		$this->scan_directory_for_cleanup( $this->theme_dir, 'theme' );
	}

	/**
	 * Cleanup uploads.
	 */
	public function cleanup_uploads() {
		$this->scan_directory_for_cleanup( $this->uploads_dir, 'uploads' );
	}

	/**
	 * Generic method to scan a directory and cleanup suspicious files.
	 *
	 * @param string $directory Directory path to scan.
	 * @param string $context   Context name for logging (e.g., 'plugin', 'theme', 'uploads').
	 */
	private function scan_directory_for_cleanup( $directory, $context ) {
		$this->logger->info( "Starting {$context} cleanup" );

		if ( ! is_dir( $directory ) ) {
			$this->logger->warning( ucfirst( $context ) . " directory not found: {$directory}" );
			return;
		}

		try {
			$files = new RecursiveIteratorIterator( new RecursiveDirectoryIterator( $directory ) );
			foreach ( $files as $file ) {
				if ( $file->isFile() ) {
					$path = $file->getPathname();

					// Validate the file.
					$validation_result = $this->validate_file( $path );
					if ( ! is_array( $validation_result ) || ! $validation_result['valid'] ) {
						$reason = is_array( $validation_result ) && isset( $validation_result['reason'] ) ? $validation_result['reason'] : 'Unknown';
						$this->logger->warning( "Suspicious {$context} file detected: " . esc_html( $path ) . ' - Reason: ' . esc_html( $reason ) );
						$this->quarantine_file( $path );
					}
				}
			}
		} catch ( Exception $e ) {
			$this->logger->error( "Error scanning {$context} directory: " . $e->getMessage() );
		}

		$this->logger->info( ucfirst( $context ) . ' cleanup completed' );
	}

	/**
	 * Validate file.
	 *
	 * @param string $path File path.
	 * @return array Validation result.
	 */
	public function validate_file( $path ) {
		$this->logger->info( 'Validating file: ' . esc_html( $path ) );

		// Check if it's a verified core file.
		if ( $this->core_integrity_checker->is_verified_core_file( $path, $this->verified_core_files ) ) {
			$this->logger->info( 'Skipping verified core file: ' . esc_html( $path ) );
			return array(
				'valid'  => true,
				'reason' => 'Verified core file',
			);
		}

		try {
			// Check file size.
			$filesize = filesize( $path );
			if ( $filesize > OMS_Config::SCAN_CONFIG['max_file_size'] ) {
				$this->logger->warning(
					sprintf( 'File exceeds maximum size limit: %s (%d bytes)', esc_html( $path ), $filesize )
				);
				return array(
					'valid'  => false,
					'reason' => 'File exceeds maximum size limit',
				);
			}

			// Check file permissions.
			$perms = fileperms( $path ) & 0777;
			if ( $perms > OMS_Config::SCAN_CONFIG['allowed_permissions']['file'] ) {
				$this->logger->warning(
					sprintf( 'File has unsafe permissions: %s (0%o)', esc_html( $path ), $perms )
				);
				return array(
					'valid'  => false,
					'reason' => 'File has unsafe permissions',
				);
			}

			// Skip excluded files.
			$basename = basename( $path );
			if ( in_array( $basename, OMS_Config::SCAN_CONFIG['excluded_files'], true ) ) {
				return array(
					'valid'  => true,
					'reason' => 'File is excluded from scan',
				);
			}

			// Check for zero-byte files.
			if ( 0 === $filesize ) {
				$this->logger->warning( sprintf( 'Zero-byte file detected: %s', esc_html( $path ) ) );
				return array(
					'valid'  => false,
					'reason' => 'Zero-byte file detected',
				);
			}

			// Then check other malicious patterns.
			$chunk_size  = $this->calculate_optimal_chunk_size();
			$scan_result = $this->scan_file_chunks( $path, $chunk_size );

			return array(
				'valid'  => ! $scan_result,
				'reason' => $scan_result ? 'Malware detected' : 'Scan passed',
			);

		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Error validating file: ' . esc_html( $path ) );
			return array(
				'valid'  => false,
				'reason' => 'Exception during validation: ' . $e->getMessage(),
			);
		}
	}

	/**
	 * Cleanup quarantine.
	 */
	public function cleanup_quarantine() {
		try {
			$quarantine_path = OMS_Config::QUARANTINE_CONFIG['path'];
			$retention_days  = OMS_Config::QUARANTINE_CONFIG['retention_days'];
			$max_size        = OMS_Config::QUARANTINE_CONFIG['max_size'];

			if ( ! is_dir( $quarantine_path ) ) {
				return;
			}

			$cutoff_time = strtotime( "-{$retention_days} days" );
			$total_size  = 0;
			$files       = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator( $quarantine_path, RecursiveDirectoryIterator::SKIP_DOTS )
			);

			foreach ( $files as $file ) {
				if ( $file->getMTime() < $cutoff_time ) {
					// phpcs:ignore WordPress.WP.AlternativeFunctions.unlink_unlink -- Security requirement: must delete old quarantine files, wp_delete_file() not suitable for bulk operations.
					unlink( $file->getPathname() );
					continue;
				}

				$total_size += $file->getSize();
			}

			// If quarantine exceeds max size, remove oldest files.
			if ( $total_size > $max_size ) {
				$files = iterator_to_array( $files );
				usort(
					$files,
					function ( $a, $b ) {
						return $a->getMTime() - $b->getMTime();
					}
				);

				foreach ( $files as $file ) {
					/**
					 * File object from iterator.
					 *
					 * @var SplFileInfo $file
					 */
					if ( $total_size <= $max_size ) {
						break;
					}
					$total_size -= $file->getSize();
					// phpcs:ignore WordPress.WP.AlternativeFunctions.unlink_unlink -- Security requirement: must delete old quarantine files, wp_delete_file() not suitable for bulk operations.
					unlink( $file->getPathname() );
				}
			}
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Error cleaning up quarantine' );
		}
	}

	/**
	 * Check file permissions.
	 */
	public function check_file_permissions() {
		$this->logger->info( 'Starting file permissions check' );

		$directories = array(
			ABSPATH,
			WP_CONTENT_DIR,
			WP_CONTENT_DIR . '/uploads',
			WP_PLUGIN_DIR,
		);

		$secure_dir_perms  = OMS_Config::SCAN_CONFIG['allowed_permissions']['dir'];
		$secure_file_perms = OMS_Config::SCAN_CONFIG['allowed_permissions']['file'];

		foreach ( $directories as $directory ) {
			$items = new RecursiveIteratorIterator( new RecursiveDirectoryIterator( $directory ) );
			foreach ( $items as $item ) {
				$path = $item->getPathname();

				$current_perms = fileperms( $path ) & 0777;

				if ( $item->isDir() && $current_perms !== $secure_dir_perms ) {
					// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_chmod -- Security requirement: must correct insecure file permissions.
					if ( chmod( $path, $secure_dir_perms ) ) {
						$this->logger->info( 'Corrected directory permissions: ' . esc_html( $path ) );
					} else {
						$this->logger->error( 'Failed to correct directory permissions: ' . esc_html( $path ) );
					}
				} elseif ( $item->isFile() && $current_perms !== $secure_file_perms ) {
					// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_chmod -- Security requirement: must correct insecure file permissions.
					if ( chmod( $path, $secure_file_perms ) ) {
						$this->logger->info( 'Corrected file permissions: ' . esc_html( $path ) );
					} else {
						$this->logger->error( 'Failed to correct file permissions: ' . esc_html( $path ) );
					}
				}
			}
		}

		$this->logger->info( 'File permissions check completed' );
	}

	/**
	 * Scan database for issues (does NOT auto-clean)
	 *
	 * Scans database for malicious content and stores results.
	 * Cleanup must be triggered manually via clean_database_issues().
	 */
	public function scan_database() {
		try {
			$this->logger->info( 'Starting database security scan' );

			$scan_result = $this->database_scanner->scan_database();

			if ( ! $scan_result['success'] ) {
				$this->logger->error( sprintf( 'Database scan failed: %s', esc_html( $scan_result['message'] ?? 'Unknown error' ) ) );
				return $scan_result;
			}

			$total_issues = $scan_result['total'] ?? 0;

			if ( $total_issues > 0 ) {
				$this->logger->warning( sprintf( 'Database scan found %d issue(s)', $total_issues ) );

				// Store issues for later cleanup (don't auto-clean).
				$this->store_pending_database_issues( $scan_result['issues'] ?? array() );

				// Notify admin of issues found.
				$this->notify_admin_of_database_issues( $scan_result );
			} else {
				$this->logger->info( 'Database scan completed - no issues found' );
				// Clear any previous pending issues.
				delete_option( 'oms_pending_db_issues' );
			}

			return $scan_result;
		} catch ( Exception $e ) {
			$this->logger->error( sprintf( 'Database scan failed: %s', esc_html( $e->getMessage() ) ) );
			return array(
				'success' => false,
				'message' => $e->getMessage(),
			);
		}
	}

	/**
	 * Store pending database issues for manual cleanup
	 *
	 * @param array $issues Issues from database scan.
	 */
	private function store_pending_database_issues( $issues ) {
		$pending = array(
			'timestamp' => time(),
			'issues'    => $issues,
		);
		update_option( 'oms_pending_db_issues', $pending, false );
	}

	/**
	 * Get pending database issues awaiting cleanup
	 *
	 * @return array|false Pending issues or false if none.
	 */
	public function get_pending_database_issues() {
		return get_option( 'oms_pending_db_issues', false );
	}

	/**
	 * Clean database issues (manual trigger only)
	 *
	 * Call this when you want to actually clean the detected issues.
	 * Uses transactions - automatically rolls back on any failure.
	 *
	 * @param array|null $specific_issues Optional specific issues to clean. If null, cleans all pending.
	 * @return array Cleanup result.
	 */
	public function clean_database_issues( $specific_issues = null ) {
		try {
			$issues_to_clean = $specific_issues;

			if ( null === $issues_to_clean ) {
				$pending = $this->get_pending_database_issues();
				if ( ! $pending || empty( $pending['issues'] ) ) {
					return array(
						'success' => true,
						'cleaned' => 0,
						'message' => 'No pending issues to clean',
					);
				}
				$issues_to_clean = $pending['issues'];
			}

			// Extract malicious content issues (the only type we actually delete).
			$malicious_issues = array();
			if ( isset( $issues_to_clean['content'] ) && is_array( $issues_to_clean['content'] ) ) {
				$malicious_issues = array_filter(
					$issues_to_clean['content'],
					static function ( $issue ) {
						return isset( $issue['type'] ) && 'malicious_content' === $issue['type'];
					}
				);
			}

			if ( empty( $malicious_issues ) ) {
				return array(
					'success' => true,
					'cleaned' => 0,
					'message' => 'No malicious content to clean',
				);
			}

			$this->logger->info( sprintf( 'Starting manual database cleanup for %d issues', count( $malicious_issues ) ) );

			$clean_result = $this->database_scanner->clean_database_content( $malicious_issues );

			if ( $clean_result['success'] ) {
				$this->logger->info( sprintf( 'Database cleanup completed: %d rows cleaned', $clean_result['cleaned'] ?? 0 ) );
				// Clear pending issues after successful cleanup.
				delete_option( 'oms_pending_db_issues' );
			} else {
				$this->logger->error( sprintf( 'Database cleanup failed (rolled back): %s', esc_html( $clean_result['message'] ?? 'Unknown error' ) ) );
			}

			return $clean_result;
		} catch ( Exception $e ) {
			$this->logger->error( sprintf( 'Database cleanup failed: %s', esc_html( $e->getMessage() ) ) );
			return array(
				'success' => false,
				'message' => $e->getMessage(),
			);
		}
	}

	/**
	 * Notify admin of database issues found
	 *
	 * @param array $scan_result Scan results.
	 */
	private function notify_admin_of_database_issues( $scan_result ) {
		$total = $scan_result['total'] ?? 0;

		// Store admin notice for display.
		set_transient(
			'oms_admin_notice_db_issues',
			array(
				'count'     => $total,
				'timestamp' => time(),
			),
			DAY_IN_SECONDS
		);

		// Send email if configured.
		if ( defined( 'OMS_NOTIFY_ADMIN' ) && OMS_NOTIFY_ADMIN ) {
			$admin_email = get_option( 'admin_email' );
			$site_name   = get_bloginfo( 'name' );
			$site_url    = home_url();

			$subject = sprintf( '[%s] Database Security Alert: %d issues found', $site_name, $total );

			$message = sprintf(
				"Security scan detected %d potential issue(s) in your database.\n\n" .
				"Site: %s\n" .
				"URL: %s\n" .
				"Time: %s\n\n" .
				"Please log in to review and clean these issues:\n%s\n\n" .
				"Issues will NOT be automatically cleaned. You must manually trigger cleanup from the admin panel.\n",
				$total,
				$site_name,
				$site_url,
				wp_date( 'Y-m-d H:i:s' ),
				admin_url( 'admin.php?page=obfuscated-malware-scanner' )
			);

			wp_mail( $admin_email, $subject, $message );
		}
	}

	/**
	 * Legacy method - now just scans without auto-cleanup
	 *
	 * @deprecated Use scan_database() and clean_database_issues() separately.
	 */
	public function cleanup_database() {
		// For backward compatibility, just scan (no auto-clean).
		$this->scan_database();
	}

	/**
	 * Log integrity issues
	 *
	 * @param array $issues Issues array from database scan.
	 */
	private function log_integrity_issues( $issues ) {
		if ( ! isset( $issues['integrity'] ) || ! is_array( $issues['integrity'] ) || empty( $issues['integrity'] ) ) {
			return;
		}

		foreach ( $issues['integrity'] as $issue ) {
			$message = isset( $issue['message'] ) ? $issue['message'] : 'Unknown';
			$this->logger->warning( sprintf( 'Database integrity issue: %s', esc_html( $message ) ) );
		}
	}

	/**
	 * Log modification issues
	 *
	 * @param array $issues Issues array from database scan.
	 */
	private function log_modification_issues( $issues ) {
		if ( ! isset( $issues['modifications'] ) || ! is_array( $issues['modifications'] ) || empty( $issues['modifications'] ) ) {
			return;
		}

		foreach ( $issues['modifications'] as $issue ) {
			$message = isset( $issue['message'] ) ? $issue['message'] : 'Unknown';
			$this->logger->warning( sprintf( 'Suspicious database modification: %s', esc_html( $message ) ) );
		}
	}

	/**
	 * Check if a file is a WordPress core file.
	 *
	 * @param string $path File path.
	 * @return bool True if core file.
	 */
	private function is_core_file( $path ) {
		$relative_path = str_replace( ABSPATH, '', $path );

		// Check wp-admin and wp-includes.
		if ( strpos( $relative_path, 'wp-admin/' ) === 0 || strpos( $relative_path, 'wp-includes/' ) === 0 ) {
			return true;
		}

		// Check root core files.
		$core_files = array(
			'index.php',
			'wp-activate.php',
			'wp-blog-header.php',
			'wp-comments-post.php',
			'wp-config-sample.php',
			'wp-cron.php',
			'wp-links-opml.php',
			'wp-load.php',
			'wp-login.php',
			'wp-mail.php',
			'wp-settings.php',
			'wp-signup.php',
			'wp-trackback.php',
			'xmlrpc.php',
		);

		if ( in_array( $relative_path, $core_files, true ) ) {
			return true;
		}

		return false;
	}






	/**
	 * Critical error handler.
	 *
	 * @param string $message Error message.
	 */
	public function critical( $message ) {
		// Log critical error with timestamp and backtrace.
		$timestamp = current_time( 'mysql' );
		$caller    = 'unknown';
		if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
			$backtrace = debug_backtrace( DEBUG_BACKTRACE_IGNORE_ARGS, 3 ); // phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_debug_backtrace -- Debug only when WP_DEBUG is enabled.
			$caller    = isset( $backtrace[1] ) ? $backtrace[1]['function'] : 'unknown';
		}

		$log_message = sprintf(
			'[%s] CRITICAL ERROR in %s: %s',
			$timestamp,
			$caller,
			$message
		);

		// Log to WordPress error log only when WP_DEBUG is enabled.
		if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
			error_log( $log_message ); // phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_error_log -- Debug logging only when WP_DEBUG is enabled.
		}

		// Log to our custom log.
		$this->logger->error( $log_message );

		// Notify admin if notifications are enabled.
		if (
			// @phpstan-ignore-next-line
			self::OMS_NOTIFY_ADMIN['enabled']
		) {
			$admin_email = get_option( 'admin_email' );
			$site_name   = get_bloginfo( 'name' );

			$subject = 'Critical Security Alert - ' . get_bloginfo( 'name' );
			$body    = sprintf(
				"Critical security issue detected:\n\nError ID: %s\nTime: %s\nMessage: %s\n%s",
				uniqid( 'OMS_ERR_' ),
				$timestamp,
				$message,
				// @phpstan-ignore-next-line
				self::OMS_NOTIFY_ADMIN['include_context'] ? "\nContext: " . $caller : ''
			);

			wp_mail( $admin_email, $subject, $body );

			// Store in database for audit trail.
			if ( function_exists( 'update_option' ) ) {
				$audit_log   = get_option( 'oms_security_audit_log', array() );
				$audit_log[] = array(
					'timestamp' => $timestamp,
					'level'     => 'CRITICAL',
					'message'   => $message,
					'caller'    => $caller,
				);

				// Keep only last 100 entries.
				if ( count( $audit_log ) > 100 ) {
					$audit_log = array_slice( $audit_log, -100 );
				}

				update_option( 'oms_security_audit_log', $audit_log );
			}
		}
	}

	/**
	 * Calculate optimal chunk size.
	 *
	 * @return int Optimal chunk size in bytes.
	 */
	public function calculate_optimal_chunk_size() {
		try {
			$memory_limit = $this->get_memory_limit();

			// Get available memory.
			$available_memory = $this->get_available_memory();

			// Get disk space.
			$available_disk_space = disk_free_space( ABSPATH );

			// Calculate base chunk size (20% of available memory).
			$base_chunk_size = (int) ( $available_memory * 0.2 );

			// Apply constraints.
			$min_chunk_size = 1024 * 1024;      // 1MB minimum.
			$max_chunk_size = 5 * 1024 * 1024;  // 5MB maximum.

			// Adjust based on available disk space.
			if ( $available_disk_space < $base_chunk_size * 10 ) {
				$base_chunk_size = (int) ( $available_disk_space * 0.1 );
			}

			// Ensure chunk size is within bounds.
			$chunk_size = max( $min_chunk_size, min( $base_chunk_size, $max_chunk_size ) );

			$this->logger->info(
				sprintf(
					'Calculated optimal chunk size: %d bytes (Memory: %d, Disk: %d)',
					$chunk_size,
					$available_memory,
					$available_disk_space
				)
			);

			return $chunk_size;
		} catch ( Exception $e ) {
			$this->logger->error( 'Error calculating chunk size: ' . esc_html( $e->getMessage() ) );
			return 1024 * 1024; // Return 1MB as safe default.
		}
	}

	/**
	 * Get memory limit.
	 *
	 * @return int Memory limit in bytes.
	 */
	private function get_memory_limit() {
		$memory_limit = ini_get( 'memory_limit' );
		if ( '-1' === $memory_limit ) {
			return PHP_INT_MAX;
		}

		if ( preg_match( '/^(\d+)(.)$/', $memory_limit, $matches ) ) {
			$value = (int) $matches[1];
			$unit  = strtolower( $matches[2] );
			switch ( $unit ) {
				case 'g':
					$value *= 1024;
					// Fall through.
				case 'm':
					$value *= 1024;
					// Fall through.
				case 'k':
					$value *= 1024;
			}
			return $value;
		}

		return 128 * 1024 * 1024; // 128MB default.
	}

	/**
	 * Get available memory.
	 *
	 * @return int Available memory in bytes.
	 */
	private function get_available_memory() {
		$memory_limit     = $this->get_memory_limit();
		$memory_usage     = memory_get_usage( true );
		$available_memory = $memory_limit - $memory_usage;

		return max( 0, $available_memory );
	}




	/**
	 * Extract match context.
	 *
	 * @param string $file File path.
	 * @param string $pattern Pattern.
	 * @return array Match context.
	 * @throws Exception If file cannot be read.
	 */
	public function extract_match_context( $file, $pattern ) {
		$this->logger->info( 'Extracting context for pattern matches in: ' . esc_html( $file ) );

		try {
			if ( ! file_exists( $file ) || ! is_readable( $file ) ) {
				throw new Exception( 'File not accessible: ' . esc_html( $file ) );
			}

			// Read file content in chunks to handle large files.
			// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fopen -- Binary file reading required for security scanning.
			$handle = fopen( $file, 'r' );
			if ( false === $handle ) {
				throw new Exception( 'Failed to open file: ' . esc_html( $file ) );
			}

			$matches       = array();
			$line_number   = 0;
			$context_lines = 3; // Number of lines before and after match.
			$buffer        = array();

			// Read file line by line.
			while ( ! feof( $handle ) ) {
				$line = fgets( $handle );
				if ( false === $line ) {
					break;
				}

				++$line_number;

				// Keep a rolling buffer of recent lines.
				$buffer[] = array(
					'number'  => $line_number,
					'content' => rtrim( $line ),
				);

				// Keep only necessary lines in buffer.
				if ( count( $buffer ) > $context_lines * 2 + 1 ) {
					array_shift( $buffer );
				}

				// Check for pattern match.
				if ( preg_match( $pattern, $line ) ) {
					// Calculate context range.
					$context_start = max( 0, count( $buffer ) - $context_lines - 1 );
					$context       = array_slice( $buffer, $context_start );

					// Store match with context.
					$matches[] = array(
						'line'    => $line_number,
						'context' => $context,
						'match'   => trim( $line ),
					);

					// Log the match.
					$this->logger->warning(
						sprintf(
							'Found match in %s on line %d: %s',
							$file,
							$line_number,
							substr( trim( $line ), 0, 100 ) . ( strlen( $line ) > 100 ? '...' : '' )
						)
					);
				}
			}

			// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fclose -- Binary file reading required for chunked malware scanning.
			fclose( $handle );

			// Format the output.
			$output = array();
			foreach ( $matches as $match ) {
				$context_str = "Match on line {$match['line']}:\n";
				foreach ( $match['context'] as $context_line ) {
					$prefix       = $context_line['number'] === $match['line'] ? '>' : ' ';
					$context_str .= sprintf(
						"%s %4d: %s\n",
						$prefix,
						$context_line['number'],
						$this->sanitize_output( $context_line['content'] )
					);
				}
				$output[] = $context_str;
			}

			return array(
				'file'     => $file,
				'pattern'  => $pattern,
				'matches'  => count( $matches ),
				'contexts' => $output,
			);
		} catch ( Exception $e ) {
			$this->logger->error( 'Error extracting match context: ' . esc_html( $e->getMessage() ) );
			return array(
				'file'     => esc_html( $file ),
				'pattern'  => esc_html( $pattern ),
				'matches'  => 0,
				'contexts' => array(),
				'error'    => esc_html( $e->getMessage() ),
			);
		}
	}

	/**
	 * Sanitize output.
	 *
	 * @param string $content Content to sanitize.
	 * @return string Sanitized content.
	 */
	private function sanitize_output( $content ) {
		// Remove null bytes and control characters.
		$content = str_replace( "\0", '', $content );
		$content = preg_replace( '/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/', '', $content );

		// Encode special characters for safe display.
		return htmlspecialchars( $content, ENT_QUOTES, 'UTF-8' );
	}

	/**
	 * Return basic status information for the admin screen.
	 *
	 * @return array Status information.
	 */
	public function get_status() {
		return array(
			'last_scan'     => get_option( 'oms_last_scan', 'never' ),
			'files_scanned' => (int) get_option( 'oms_files_scanned', 0 ),
			'issues_found'  => (int) get_option( 'oms_issues_found', 0 ),
			'issues'        => array(),
		);
	}
	/**
	 * Set security policy instance.
	 *
	 * @param OMS_File_Security_Policy $policy Security policy instance.
	 */
	public function set_security_policy( $policy ) {
		$this->security_policy = $policy;
	}

	/**
	 * Set logger instance.
	 *
	 * @param OMS_Logger $logger Logger instance.
	 */
	public function set_logger( $logger ) {
		$this->logger = $logger;
	}
}
