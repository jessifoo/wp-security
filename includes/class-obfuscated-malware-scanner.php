<?php
/**
 * Main plugin class for malware scanner
 *
 * @package ObfuscatedMalwareScanner
 */

// If this file is called directly, abort.
if ( ! defined( 'ABSPATH' ) ) {
	die( 'Direct access is not allowed.' );
}

require_once __DIR__ . '/class-oms-config.php';
require_once __DIR__ . '/class-oms-logger.php';
require_once __DIR__ . '/class-oms-utils.php';
require_once __DIR__ . '/class-oms-exception.php';

/**
 * Main plugin class.
 */
class Obfuscated_Malware_Scanner {
	/**
	 * Logger instance.
	 *
	 * @var OMS_Logger
	 */
	private $logger;

	/**
	 * Exception handler instance.
	 *
	 * @var OMS_Exception
	 */
	private $exception;

	/**
	 * Compiled patterns array.
	 *
	 * @var array
	 */
	private $compiled_patterns;

	const RATE_LIMITS       = 5; // Define RATE_LIMITS constant.
	const BACKDOOR_PATTERNS = array(); // Define BACKDOOR_PATTERNS constant.
	/**
	 * Admin notification settings
	 */
	const OMS_NOTIFY_ADMIN = array(
		'enabled'                    => true,
		'severity_threshold'         => 'warning',  // Minimum severity level to notify.
		'batch_interval'             => 3600,      // Seconds between notification batches.
		'max_notifications_per_hour' => 10,      // Prevent notification flood.
		'include_context'            => true,       // Include surrounding code context.
		'notification_types'         => array(
			'malware_detected'   => true,
			'zero_byte_files'    => true,
			'permission_changes' => true,
			'critical_errors'    => true,
			'quarantine_actions' => true,
		),
	);

	/**
	 * Cache instance.
	 *
	 * @var OMS_Cache
	 */
	private $cache;

	/**
	 * Rate limiter instance.
	 *
	 * @var OMS_Rate_Limiter
	 */
	private $rate_limiter;

	/**
	 * Security policy instance.
	 *
	 * @var OMS_File_Security_Policy
	 */
	private $security_policy;

	/**
	 * Scanner instance.
	 *
	 * @var OMS_Scanner
	 */
	private $scanner;

	/**
	 * Constructor.
	 */
	public function __construct() {
		try {
			$this->logger            = new OMS_Logger();
			$this->cache             = new OMS_Cache();
			$this->rate_limiter      = new OMS_Rate_Limiter( array( 'default' => self::RATE_LIMITS ) );
			$this->security_policy   = new OMS_File_Security_Policy();
			$this->compiled_patterns = $this->load_or_compile_patterns();
			$this->logger->info( 'Scanner initialized successfully' );
		} catch ( OMS_Exception $e ) {
			// Log initialization error but don't throw to prevent breaking site.
			error_log( 'OMS initialization failed: ' . esc_html( $e->getMessage() ) );
		}
	}

	/**
	 * Initialize the plugin.
	 */
	public function init() {
		try {
			$this->setup_hooks();
			$this->logger->info( 'Plugin hooks initialized successfully' );
		} catch ( OMS_Exception $e ) {
			$this->handle_exception( $e, 'Failed to initialize plugin hooks' );
		}
	}

	/**
	 * Set up WordPress hooks and filters.
	 *
	 * @throws OMS_Exception If WordPress functions are not available.
	 */
	private function setup_hooks() {
		if ( ! function_exists( 'register_activation_hook' ) ) {
			throw new OMS_Exception( 'WordPress functions not available' );
		}

		// Note: Activation hook is registered in the main plugin file (obfuscated-malware-scanner.php)
		// to ensure proper plugin initialization order.

		if ( ! wp_next_scheduled( 'oms_daily_cleanup' ) ) {
			wp_schedule_event( time(), 'daily', 'oms_daily_cleanup' );
		}

		add_action( 'oms_daily_cleanup', array( $this, 'run_full_cleanup' ) );
		add_action( 'added_post_meta', array( $this, 'check_uploaded_file' ), 10, 4 );
		add_filter( 'upload_dir', array( $this, 'sanitize_upload_path' ) );
	}

	/**
	 * Load or compile malware patterns.
	 *
	 * @return array Compiled patterns.
	 * @throws OMS_Exception If pattern compilation fails.
	 */
	private function load_or_compile_patterns() {
		try {
			$patterns = array_merge(
				OMS_Config::OBFUSCATION_PATTERNS,
				OMS_Config::MALWARE_PATTERNS
			);

			$compiled = array();
			foreach ( $patterns as $pattern ) {
				// Validate regex pattern without suppressing errors.
				$last_error    = error_get_last();
				$test_result   = preg_match( '#' . $pattern['pattern'] . '#i', '' );
				$current_error = error_get_last();
				if ( false === $test_result || ( $current_error !== $last_error && preg_last_error() !== PREG_NO_ERROR ) ) {
					$error_msg = ( $current_error !== $last_error ) ? $current_error['message'] : 'Invalid regex pattern';
					$this->logger->warning( 'Invalid pattern skipped: ' . $pattern['pattern'] . ' - ' . esc_html( $error_msg ) );
					continue;
				}
				$compiled[] = array(
					'pattern'     => '#' . $pattern['pattern'] . '#i',
					'severity'    => $pattern['severity'],
					'description' => $pattern['description'],
				);
			}

			return $compiled;
		} catch ( Exception $e ) {
			throw new OMS_Exception( 'Failed to compile patterns: ' . esc_html( $e->getMessage() ) );
		}
	}

	/**
	 * Perform a full cleanup of the site.
	 */
	public function run_full_cleanup() {
		try {
			$this->logger->info( 'Starting full cleanup' );
			$this->cleanup_core_files();
			$this->cleanup_plugins();
			$this->cleanup_uploads();
			$this->cleanup_quarantine();
			$this->check_file_permissions();
			$this->logger->info( 'Full cleanup completed successfully' );
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Full cleanup failed' );
		}
	}

	/**
	 * Cleanup WordPress core files.
	 */
	private function cleanup_core_files() {
		try {
			$checksums = $this->get_core_checksums();
			foreach ( $checksums as $file => $checksum ) {
				$this->process_core_file( $file, $checksum );
			}
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Core file cleanup failed' );
		}
	}

	/**
	 * Process a core file.
	 *
	 * @param string $file File path.
	 * @param string $checksum Expected checksum.
	 */
	private function process_core_file( $file, $checksum ) {
		$file_path = OMS_Utils::sanitize_path( ABSPATH . $file );

		if ( ! OMS_Utils::is_path_safe( $file_path ) ) {
			$this->logger->warning( 'Skipping unsafe path: ' . esc_html( $file_path ) );
			return;
		}

		if ( ! is_readable( $file_path ) ) {
			$this->download_core_file( $file );
			return;
		}

		$file_hash = md5_file( $file_path );
		if ( $checksum !== $file_hash ) {
			$this->logger->warning( 'Checksum mismatch for: ' . esc_html( $file_path ) );
			$this->download_core_file( $file );
		}
	}

	/**
	 * Download a core file.
	 *
	 * @param string $file File path.
	 * @param int    $retry Number of retries.
	 * @return bool True if successful.
	 */
	private function download_core_file( $file, $retry = 3 ) {
		$url         = sprintf( 'https://core.svn.wordpress.org/tags/%s/%s', get_bloginfo( 'version' ), $file );
		$destination = ABSPATH . $file;

		while ( $retry-- > 0 ) {
			if ( $this->download_file( $url, $destination ) ) {
				$this->logger->info( 'Downloaded core file', array( 'file' => $file ) );
				return true;
			}
			sleep( 2 ); // Backoff delay.
		}
		$this->logger->error( 'Failed to download core file after retries', array( 'file' => $file ) );
		return false;
	}

	/**
	 * Validate and sanitize uploaded files.
	 *
	 * @param int    $meta_id Meta ID.
	 * @param int    $post_id Post ID.
	 * @param string $meta_key Meta key.
	 * @param mixed  $meta_value Meta value.
	 */
	public function check_uploaded_file( $meta_id, $post_id, $meta_key, $meta_value ) {
		if ( '_wp_attached_file' !== $meta_key ) {
			return;
		}

		$upload_dir = wp_upload_dir();
		$file_path  = OMS_Utils::sanitize_path( $upload_dir['basedir'] . '/' . $meta_value );

		if ( ! $this->security_policy->validate_file( $file_path )['valid'] || $this->contains_malware( $file_path ) ) {
			$this->quarantine_file( $file_path );
			wp_delete_attachment( $post_id, true );
			$this->logger->warning( 'Malicious file quarantined: ' . esc_html( $file_path ) );
		}
	}

	/**
	 * Scan a file for malware patterns with improved obfuscation detection.
	 *
	 * @param string $path File path.
	 * @return bool True if malware detected.
	 */
	public function contains_malware( $path ) {
		try {
			if ( ! file_exists( $path ) || ! is_readable( $path ) ) {
				$this->logger->warning( 'File not accessible', array( 'path' => $path ) );
				return true; // Treat inaccessible files as suspicious.
			}

			// Check file size.
			$filesize = filesize( $path );
			if ( false === $filesize ) {
				$this->logger->warning( 'Failed to get file size', array( 'path' => $path ) );
				return true; // Treat files with unreadable size as suspicious.
			}
			if ( 0 === $filesize ) {
				$this->logger->warning( 'Empty or zero-byte file detected', array( 'path' => $path ) );
				return true; // Treat zero-byte files as suspicious.
			}

			// First check for binary files that shouldn't contain PHP.
			if ( $this->is_binary_file( $path ) && $this->contains_php_code( $path ) ) {
				$this->logger->error( 'PHP code found in binary file', array( 'path' => $path ) );
				return true;
			}

			// Scan with new obfuscation patterns first.
			foreach ( OMS_Config::OBFUSCATION_PATTERNS as $pattern ) {
				if ( $this->match_pattern( $path, $pattern['pattern'] ) ) {
					$this->logger->info(
						$pattern['severity'],
						'Detected ' . esc_html( $pattern['description'] ),
						array(
							'path'    => $path,
							'pattern' => $pattern['pattern'],
						)
					);
					return true;
				}
			}

			// Then check other malicious patterns.
			$chunk_size = $this->calculate_optimal_chunk_size();
			return $this->scan_file_chunks( $path, $chunk_size );
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Error scanning file: ' . esc_html( $path ) );
			return true; // Treat exceptions as suspicious.
		}
	}

	/**
	 * Check if a file is a binary file that shouldn't contain PHP code.
	 *
	 * @param string $path File path.
	 * @return bool True if binary file.
	 */
	private function is_binary_file( $path ) {
		$extension = strtolower( pathinfo( $path, PATHINFO_EXTENSION ) );
		return in_array( $extension, array( 'jpg', 'jpeg', 'png', 'gif', 'pdf', 'zip' ), true );
	}

	/**
	 * Check if a file contains PHP code.
	 *
	 * @param string $path File path.
	 * @return bool True if PHP code found.
	 */
	private function contains_php_code( $path ) {
		// Read first 1024 bytes to check for PHP signature.
		$handle = fopen( $path, 'rb' );
		if ( false === $handle ) {
			return false;
		}

		$content = fread( $handle, 1024 );
		fclose( $handle );

		return 1 === preg_match( '/<\?php|<\?=|\xFF\xD8\xFF\xE0.*<\?php/s', $content );
	}

	/**
	 * Match a pattern against a file with proper error handling.
	 *
	 * @param string $path File path.
	 * @param string $pattern Pattern to match.
	 * @return bool True if pattern matches.
	 * @throws Exception If file cannot be read.
	 */
	private function match_pattern( $path, $pattern ) {
		try {
			$content = file_get_contents( $path );
			if ( false === $content ) {
				throw new Exception( 'Failed to read file contents' );
			}
			return 1 === preg_match( "/$pattern/i", $content );
		} catch ( Exception $e ) {
			$this->logger->error(
				'Pattern matching failed',
				array(
					'path'    => $path,
					'pattern' => $pattern,
					'error'   => $e->getMessage(),
				)
			);
			return false;
		}
	}

	/**
	 * Scan a file for malware patterns.
	 *
	 * @param string $file_path File path.
	 * @param int    $chunk_size Chunk size.
	 * @return bool True if malware found.
	 * @throws Exception If file cannot be read.
	 */
	public function scan_file_chunks( $file_path, $chunk_size ) {
		try {
			if ( ! is_readable( $file_path ) ) {
				throw new Exception( 'File not readable: ' . esc_html( $file_path ) );
			}

			$file_size = filesize( $file_path );
			if ( 0 === $file_size ) {
				$this->logger->warning( 'Zero-byte file detected: ' . esc_html( $file_path ), 'warning' );
				return false;
			}

			$handle = fopen( $file_path, 'rb' );
			if ( false === $handle ) {
				throw new Exception( 'Failed to open file: ' . esc_html( $file_path ) );
			}

			$matches              = array();
			$offset               = 0;
			$overlap              = OMS_Config::SCAN_CONFIG['overlap_size']; // Overlap between chunks to catch patterns spanning chunks.
			$suspicious_patterns  = $this->get_malware_patterns();
			$start_time           = microtime( true );
			$last_progress_update = 0;

			while ( ! feof( $handle ) ) {
				// Check for timeout.
				if ( microtime( true ) - $start_time > OMS_Config::SECURITY_CONFIG['max_execution_time'] ) { // 5 minutes timeout.
					throw new Exception( 'Scan timeout for file: ' . esc_html( $file_path ) );
				}

				// Throttle if needed.
				if ( $this->should_throttle() ) {
					usleep( OMS_Config::SCAN_CONFIG['batch_pause'] * 1000 ); // Pause in milliseconds.
				}

				// Read chunk with overlap.
				$chunk = fread( $handle, $chunk_size + $overlap );
				if ( false === $chunk ) {
					throw new Exception( 'Failed to read chunk from file: ' . esc_html( $file_path ) );
				}

				// Update progress every 5%.
				$progress = ( $offset / $file_size ) * 100;
				if ( $progress - $last_progress_update >= 5 ) {
					$this->logger->info( sprintf( 'Scanning %s: %.1f%% complete', esc_html( basename( $file_path ) ), $progress ) );
					$last_progress_update = $progress;
				}

				// Check for malicious patterns.
				foreach ( $suspicious_patterns as $pattern ) {
					if ( preg_match( $pattern['pattern'], $chunk, $pattern_matches, PREG_OFFSET_CAPTURE ) ) {
						$matches[] = array(
							'pattern'     => $pattern['pattern'],
							'description' => $pattern['description'],
							'offset'      => $offset + $pattern_matches[0][1],
							'match'       => $pattern_matches[0][0],
							'context'     => $this->extract_match_context( $file_path, $pattern['pattern'] ),
						);

						$this->logger->warning(
							sprintf(
								'Found suspicious pattern in %s: %s at offset %d',
								esc_html( basename( $file_path ) ),
								esc_html( $pattern['description'] ),
								$offset + $pattern_matches[0][1]
							),
							'warning'
						);
					}
				}

				// Move back by overlap amount unless at EOF.
				if ( ! feof( $handle ) ) {
					fseek( $handle, $offset + $chunk_size - $overlap );
				}

				$offset += $chunk_size - $overlap;
			}

			fclose( $handle );

			// Log completion.
			$scan_time = microtime( true ) - $start_time;
			$this->logger->info(
				sprintf(
					'Completed scanning %s in %.2f seconds. Found %d suspicious patterns.',
					esc_html( basename( $file_path ) ),
					$scan_time,
					count( $matches )
				),
				'info'
			);

			if ( ! empty( $matches ) ) {
				// Store detailed results for admin review.
				$this->logger->warning( $file_path, $matches );
				return false; // File contains suspicious patterns.
			}

			return true; // File is clean.

		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Error scanning file chunks: ' . esc_html( $file_path ) );
			return false;
		}
	}

	/**
	 * Get malware patterns.
	 *
	 * @return array Malware patterns.
	 */
	private function get_malware_patterns() {
		return OMS_Config::MALWARE_PATTERNS;
	}

	/**
	 * Get log path.
	 *
	 * @return string Log path.
	 */
	private function get_log_path() {
		$log_path = OMS_Config::LOG_CONFIG['path'];
		if ( ! is_dir( $log_path ) ) {
			wp_mkdir_p( $log_path );
			$htaccess = $log_path . '/.htaccess';
			if ( ! file_exists( $htaccess ) ) {
				file_put_contents( $htaccess, 'Deny from all' );
			}
		}
		return $log_path;
	}

	/**
	 * Get quarantine path.
	 *
	 * @return string Quarantine path.
	 */
	private function get_quarantine_path() {
		$quarantine_path = OMS_Config::QUARANTINE_CONFIG['path'];
		if ( ! is_dir( $quarantine_path ) ) {
			wp_mkdir_p( $quarantine_path );
			$htaccess = $quarantine_path . '/.htaccess';
			if ( ! file_exists( $htaccess ) ) {
				file_put_contents( $htaccess, 'Deny from all' );
			}
		}
		return $quarantine_path;
	}

	/**
	 * Check if log level is valid.
	 *
	 * @param string $level Log level.
	 * @return bool True if valid.
	 */
	private function is_valid_log_level( $level ) {
		return in_array( strtolower( $level ), OMS_Config::LOG_CONFIG['levels'], true );
	}

	/**
	 * Enforce execution limits.
	 */
	private function enforce_execution_limits() {
		$settings = array(
			'max_execution_time'  => OMS_Config::SECURITY_CONFIG['max_execution_time'],
			'memory_limit'        => OMS_Config::SECURITY_CONFIG['memory_limit'],
			'max_input_time'      => OMS_Config::SECURITY_CONFIG['max_input_time'],
			'max_input_vars'      => OMS_Config::SECURITY_CONFIG['max_input_vars'],
			'post_max_size'       => OMS_Config::SECURITY_CONFIG['post_max_size'],
			'upload_max_filesize' => OMS_Config::SECURITY_CONFIG['upload_max_filesize'],
		);

		foreach ( $settings as $setting => $value ) {
			$result = ini_set( $setting, $value );
			if ( false === $result ) {
				$this->logger->warning(
					'Failed to set PHP ini setting',
					array(
						'setting' => $setting,
						'value'   => $value,
					)
				);
			}
		}
	}

	/**
	 * Check if path is excluded.
	 *
	 * @param string $path Path to check.
	 * @return bool True if excluded.
	 */
	private function is_excluded_path( $path ) {
		$basename = basename( $path );
		if ( in_array( $basename, OMS_Config::SCAN_CONFIG['excluded_files'], true ) ) {
			return true;
		}

		foreach ( OMS_Config::SCAN_CONFIG['excluded_dirs'] as $dir ) {
			if ( strpos( $path, "/$dir/" ) !== false ) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Quarantine a file with fallback options and safety checks.
	 *
	 * @param string $path Path to the file to quarantine.
	 * @return bool True if quarantine succeeded, false otherwise.
	 * @throws Exception If quarantine fails.
	 */
	private function quarantine_file( $path ) {
		try {
			$quarantine_dir = OMS_Config::QUARANTINE_CONFIG['path'];

			// Ensure quarantine directory exists and is writable.
			if ( ! file_exists( $quarantine_dir ) ) {
				$mkdir_result = mkdir( $quarantine_dir, 0755, true );
				if ( ! $mkdir_result ) {
					$error     = error_get_last();
					$error_msg = ( $error && isset( $error['message'] ) ) ? $error['message'] : 'Unknown error';
					$this->logger->error(
						'Failed to create quarantine directory',
						array(
							'path'  => $quarantine_dir,
							'error' => esc_html( $error_msg ),
						)
					);
					throw new Exception( 'Failed to create quarantine directory: ' . esc_html( $error_msg ) );
				}
			}

			if ( ! is_writable( $quarantine_dir ) ) {
				throw new Exception( 'Quarantine directory is not writable' );
			}

			// Generate unique quarantine filename.
			$timestamp       = gmdate( 'Y-m-d_H-i-s' );
			$unique_id       = uniqid();
			$quarantine_path = sprintf(
				'%s/%s_%s_%s.quarantine',
				$quarantine_dir,
				pathinfo( $path, PATHINFO_FILENAME ),
				$timestamp,
				$unique_id
			);

			// Try primary quarantine method (rename).
			$rename_result = rename( $path, $quarantine_path );
			if ( $rename_result ) {
				$this->logger->info(
					'File quarantined successfully',
					array(
						'original_path'   => $path,
						'quarantine_path' => $quarantine_path,
						'method'          => 'rename',
					)
				);
				return true;
			} else {
				$error = error_get_last();
				$this->logger->warning(
					'Failed to rename file for quarantine',
					array(
						'path'  => $path,
						'error' => ( $error && isset( $error['message'] ) ) ? esc_html( $error['message'] ) : 'Unknown error',
					)
				);
			}

			// Fallback 1: Try copy and delete.
			$copy_result = copy( $path, $quarantine_path );
			if ( $copy_result ) {
				$unlink_result = unlink( $path );
				if ( $unlink_result ) {
					$this->logger->info(
						'File quarantined using copy/delete',
						array(
							'original_path'   => $path,
							'quarantine_path' => $quarantine_path,
							'method'          => 'copy_delete',
						)
					);
					return true;
				} else {
					$error = error_get_last();
					$this->logger->warning(
						'Failed to delete original file after copy',
						array(
							'path'  => $path,
							'error' => ( $error && isset( $error['message'] ) ) ? esc_html( $error['message'] ) : 'Unknown error',
						)
					);
					// If we can't delete the original, remove the quarantine copy.
					$unlink_quarantine = unlink( $quarantine_path );
					if ( ! $unlink_quarantine ) {
						$error = error_get_last();
						$this->logger->error(
							'Failed to remove quarantine copy after failed delete',
							array(
								'quarantine_path' => $quarantine_path,
								'error'           => ( $error && isset( $error['message'] ) ) ? esc_html( $error['message'] ) : 'Unknown error',
							)
						);
					}
				}
			} else {
				$error = error_get_last();
				$this->logger->warning(
					'Failed to copy file for quarantine',
					array(
						'path'  => $path,
						'error' => ( $error && isset( $error['message'] ) ) ? esc_html( $error['message'] ) : 'Unknown error',
					)
				);
			}

			// Fallback 2: Try to make file inaccessible.
			if ( $this->make_file_inaccessible( $path ) ) {
				$this->logger->warning(
					'File made inaccessible as quarantine fallback',
					array(
						'path'   => $path,
						'method' => 'chmod',
					)
				);
				return true;
			}

			throw new Exception( 'All quarantine methods failed' );
		} catch ( Exception $e ) {
			$this->logger->error(
				'Quarantine failed',
				array(
					'path'  => $path,
					'error' => $e->getMessage(),
					'trace' => $e->getTraceAsString(),
				)
			);
			return false;
		}
	}

	/**
	 * Make a file inaccessible as a last resort.
	 *
	 * @param string $path Path to the file.
	 * @return bool True if successful, false otherwise.
	 */
	private function make_file_inaccessible( $path ) {
		// Try to remove all permissions.
		$chmod_result = chmod( $path, 0000 );
		if ( $chmod_result ) {
			return true;
		} else {
			$error = error_get_last();
			$this->logger->warning(
				'Failed to chmod file to 0000',
				array(
					'path'  => $path,
					'error' => ( $error && isset( $error['message'] ) ) ? esc_html( $error['message'] ) : 'Unknown error',
				)
			);
		}

		// Fallback: try to make file unreadable.
		$chmod_result = chmod( $path, 0333 );
		if ( $chmod_result ) {
			return true;
		} else {
			$error = error_get_last();
			$this->logger->warning(
				'Failed to chmod file to 0333',
				array(
					'path'  => $path,
					'error' => ( $error && isset( $error['message'] ) ) ? esc_html( $error['message'] ) : 'Unknown error',
				)
			);
		}

		return false;
	}

	/**
	 * Handle exceptions with proper logging and notifications.
	 *
	 * @param Exception $e The exception to handle.
	 * @param string    $context Additional context about where the exception occurred.
	 */
	private function handle_exception( Exception $e, $context = '' ) {
		$severity = ( $e instanceof OMS_Exception ) ? 'HIGH' : 'CRITICAL';

		// Log the error with full context.
		$this->logger->error(
			sprintf(
				"%s: %s\nStack trace: %s",
				$context,
				$e->getMessage(),
				$e->getTraceAsString()
			)
		);

		// Notify admin based on severity.
		if ( $this->should_notify_admin( $severity ) ) {
			$this->notify_admin( $context, $e );
		}
	}

	/**
	 * Check if admin should be notified based on severity and settings.
	 *
	 * @param string $severity The severity level to check.
	 * @return bool Whether admin should be notified.
	 */
	private function should_notify_admin( $severity ) {
		$severity_level  = OMS_Config::SEVERITY_LEVELS[ $severity ] ?? OMS_Config::SEVERITY_LEVELS['LOW'];
		$threshold_level = OMS_Config::SEVERITY_LEVELS[ OMS_Config::NOTIFICATION_THRESHOLD ] ?? OMS_Config::SEVERITY_LEVELS['MEDIUM'];

		return $severity_level >= $threshold_level;
	}

	/**
	 * Send notification to admin.
	 *
	 * @param string    $context The context of the notification.
	 * @param Exception $e The exception that triggered the notification.
	 * @throws OMS_Exception If admin email is not configured.
	 */
	private function notify_admin( $context, Exception $e ) {
		try {
			$admin_email = get_option( 'admin_email' );
			if ( ! $admin_email ) {
				throw new OMS_Exception( 'Admin email not configured' );
			}

			$site_name = get_bloginfo( 'name' );
			$subject   = sprintf( 'Security Alert - %s', $site_name );

			$body = sprintf(
				"Security issue detected:\n\nContext: %s\nError ID: %s\nTime: %s\nMessage: %s\nStack trace: %s",
				$context,
				uniqid( 'OMS_ERR_' ),
				current_time( 'mysql' ),
				$e->getMessage(),
				$e->getTraceAsString()
			);

			wp_mail( $admin_email, $subject, $body );
			$this->logger->info( "Security notification sent to admin: $admin_email" );
		} catch ( Exception $notify_error ) {
			$this->logger->error( 'Failed to send admin notification: ' . $notify_error->getMessage() );
		}
	}

	/**
	 * Cleanup plugins.
	 */
	public function cleanup_plugins() {
		$this->logger->info( 'Starting plugin cleanup' );

		// Get all installed plugins.
		$plugins = get_plugins();
		foreach ( $plugins as $plugin_path => $plugin_data ) {
			$full_path = WP_PLUGIN_DIR . '/' . $plugin_path;

			// Scan each plugin file.
			$files = new RecursiveIteratorIterator( new RecursiveDirectoryIterator( $full_path ) );
			foreach ( $files as $file ) {
				if ( $file->isFile() ) {
					$path = $file->getPathname();

					// Check for malware patterns.
					if ( $this->contains_malware( $path ) ) {
						$this->logger->warning( 'Malware detected in plugin file: ' . esc_html( $path ) );
						$this->quarantine_file( $path );
					}
				}
			}
		}

		$this->logger->info( 'Plugin cleanup completed' );
	}

	/**
	 * Cleanup uploads.
	 */
	public function cleanup_uploads() {
		$this->logger->info( 'Starting uploads cleanup' );

		$uploads_dir = WP_CONTENT_DIR . '/uploads';
		$files       = new RecursiveIteratorIterator( new RecursiveDirectoryIterator( $uploads_dir ) );
		foreach ( $files as $file ) {
			if ( $file->isFile() ) {
				$path = $file->getPathname();

				// Validate the file.
				$validation_result = $this->validate_file( $path );
				if ( ! $validation_result['valid'] ) {
					$this->logger->warning( 'Suspicious file detected: ' . esc_html( $path ) . ' - Reason: ' . esc_html( $validation_result['reason'] ) );
					$this->quarantine_file( $path );
				}
			}
		}

		$this->logger->info( 'Uploads cleanup completed' );
	}

	/**
	 * Validate file.
	 *
	 * @param string $path File path.
	 * @return bool True if valid.
	 */
	public function validate_file( $path ) {
		$this->logger->info( 'Validating file: ' . esc_html( $path ) );

		try {
			// Check file size.
			$filesize = filesize( $path );
			if ( $filesize > OMS_Config::SCAN_CONFIG['max_file_size'] ) {
				$this->logger->warning(
					sprintf(
						'File exceeds maximum size limit: %s (%d bytes)',
						$path,
						$filesize
					),
					'warning'
				);
				return false;
			}

			// Check file permissions.
			$perms = fileperms( $path ) & 0777;
			if ( $perms > OMS_Config::SCAN_CONFIG['allowed_permissions']['file'] ) {
				$this->logger->warning(
					sprintf(
						'File has unsafe permissions: %s (0%o)',
						$path,
						$perms
					),
					'warning'
				);
				return false;
			}

			// Skip excluded files.
			$basename = basename( $path );
			if ( in_array( $basename, OMS_Config::SCAN_CONFIG['excluded_files'], true ) ) {
				return true;
			}

			// Check for zero-byte files.
			if ( 0 === $filesize ) {
				$this->logger->warning( "Zero-byte file detected: $path", 'warning' );
				return false;
			}

			// Then check other malicious patterns.
			$chunk_size = $this->calculateOptimalChunkSize();
			$this->scan_file_chunks( $path, $chunk_size );
		} catch ( Exception $e ) {
			$this->handle_exception( $e, "Error validating file: $path" );
			return false;
		}
	}

	/**
	 * Cleanup quarantine.
	 */
	public function cleanup_quarantine() {
		try {
			$quarantine_path = OMS_Config::QUARANTINE_CONFIG['path'];
			$retention_days  = OMS_Config::QUARANTINE_CONFIG['retention_days'];
			$max_size        = OMS_Config::QUARANTINE_CONFIG['max_size'];

			if ( ! is_dir( $quarantine_path ) ) {
				return;
			}

			$cutoff_time = strtotime( "-{$retention_days} days" );
			$total_size  = 0;
			$files       = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator( $quarantine_path, RecursiveDirectoryIterator::SKIP_DOTS )
			);

			foreach ( $files as $file ) {
				if ( $file->getMTime() < $cutoff_time ) {
					unlink( $file->getPathname() );
					continue;
				}

				$total_size += $file->getSize();
			}

			// If quarantine exceeds max size, remove oldest files.
			if ( $total_size > $max_size ) {
				$files = iterator_to_array( $files );
				usort(
					$files,
					function ( $a, $b ) {
						return $a->getMTime() - $b->getMTime();
					}
				);

				foreach ( $files as $file ) {
					if ( $total_size <= $max_size ) {
						break;
					}
					$total_size -= $file->getSize();
					unlink( $file->getPathname() );
				}
			}
		} catch ( Exception $e ) {
			$this->handle_exception( $e, 'Error cleaning up quarantine' );
		}
	}

	/**
	 * Check file permissions.
	 */
	public function check_file_permissions() {
		$this->logger->info( 'Starting file permissions check' );

		$directories = array(
			ABSPATH,
			WP_CONTENT_DIR,
			WP_CONTENT_DIR . '/uploads',
			WP_PLUGIN_DIR,
		);

		$secure_dir_perms  = OMS_Config::SCAN_CONFIG['allowed_permissions']['dir'];
		$secure_file_perms = OMS_Config::SCAN_CONFIG['allowed_permissions']['file'];

		foreach ( $directories as $directory ) {
			$items = new RecursiveIteratorIterator( new RecursiveDirectoryIterator( $directory ) );
			foreach ( $items as $item ) {
				$path = $item->getPathname();

				$current_perms = fileperms( $path ) & 0777;

				if ( $item->isDir() && $current_perms !== $secure_dir_perms ) {
					if ( chmod( $path, $secure_dir_perms ) ) {
						$this->logger->info( "Corrected directory permissions: $path" );
					} else {
						$this->logger->error( "Failed to correct directory permissions: $path" );
					}
				} elseif ( $item->isFile() && $current_perms !== $secure_file_perms ) {
					if ( chmod( $path, $secure_file_perms ) ) {
						$this->logger->info( "Corrected file permissions: $path" );
					} else {
						$this->logger->error( "Failed to correct file permissions: $path" );
					}
				}
			}
		}

		$this->logger->info( 'File permissions check completed' );
	}

	/**
	 * Get core checksums.
	 *
	 * @return array Core file checksums.
	 * @throws Exception If checksum retrieval fails.
	 */
	public function get_core_checksums() {
		$this->logger->info( 'Retrieving WordPress core checksums' );

		try {
			global $wp_version;
			$locale = get_locale();

			// Check cache first.
			$cache_key        = "wp_checksums_{$wp_version}_{$locale}";
			$cached_checksums = $this->cache->get( $cache_key );
			if ( $cached_checksums ) {
				return $cached_checksums;
			}

			// Construct API URL.
			$url = sprintf(
				'https://api.wordpress.org/core/checksums/1.0/?version=%s&locale=%s',
				$wp_version,
				$locale
			);

			// Fetch checksums from WordPress API.
			$response = wp_remote_get( $url );
			if ( is_wp_error( $response ) ) {
				throw new Exception( 'Failed to fetch WordPress checksums: ' . $response->get_error_message() );
			}

			$body = wp_remote_retrieve_body( $response );
			$data = json_decode( $body, true );

			if ( empty( $data ) || ! isset( $data['checksums'] ) || ! is_array( $data['checksums'] ) ) {
				throw new Exception( 'Invalid checksum data received from WordPress API' );
			}

			// Cache the checksums.
			$this->cache->set( $cache_key, $data['checksums'], 3600 ); // Cache for 1 hour.

			$this->logger->info( 'Successfully retrieved WordPress core checksums' );
			return $data['checksums'];
		} catch ( Exception $e ) {
			$this->logger->error( 'Error retrieving WordPress core checksums: ' . $e->getMessage() );
			return array();
		}
	}

	/**
	 * Download file.
	 *
	 * @param string $url URL to download.
	 * @param string $destination Destination path.
	 * @return bool True if successful.
	 * @throws Exception If download fails.
	 */
	public function download_file( $url, $destination ) {
		$this->logger->info( 'Downloading file from: ' . esc_html( $url ) . ' to: ' . esc_html( $destination ) );

		try {
			// Validate URL.
			if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) {
				throw new Exception( 'Invalid URL provided' );
			}

			// Validate destination directory.
			$dest_dir = dirname( $destination );
			if ( ! is_dir( $dest_dir ) ) {
				if ( ! mkdir( $dest_dir, 0755, true ) ) {
					throw new Exception( "Failed to create destination directory: $dest_dir" );
				}
			}

			if ( ! is_writable( $dest_dir ) ) {
				throw new Exception( "Destination directory is not writable: $dest_dir" );
			}

			// Download file using WordPress functions.
			$response = wp_remote_get(
				$url,
				array(
					'timeout'  => 300,
					'stream'   => true,
					'filename' => $destination,
				)
			);

			if ( is_wp_error( $response ) ) {
				throw new Exception( 'Download failed: ' . $response->get_error_message() );
			}

			// Verify file was downloaded.
			if ( ! file_exists( $destination ) ) {
				throw new Exception( 'File download failed: File not found at destination' );
			}

			// Verify file size.
			$file_size = filesize( $destination );
			if ( 0 === $file_size ) {
				unlink( $destination );
				throw new Exception( 'Downloaded file is empty' );
			}

			$this->logger->info( "File downloaded successfully: $destination" );
			return true;
		} catch ( Exception $e ) {
			$this->logger->error( 'File download error: ' . $e->getMessage() );
			if ( file_exists( $destination ) ) {
				unlink( $destination );
			}
			return false;
		}
	}

	/**
	 * Critical error handler.
	 *
	 * @param string $message Error message.
	 */
	public function critical( $message ) {
		// Log critical error with timestamp and backtrace.
		$timestamp = current_time( 'mysql' );
		$backtrace = debug_backtrace( DEBUG_BACKTRACE_IGNORE_ARGS, 3 );
		$caller    = isset( $backtrace[1] ) ? $backtrace[1]['function'] : 'unknown';

		$log_message = sprintf(
			'[%s] CRITICAL ERROR in %s: %s',
			$timestamp,
			$caller,
			$message
		);

		// Log to WordPress error log.
		error_log( $log_message );

		// Log to our custom log.
		$this->logger->error( $log_message );

		// Notify admin if enabled and critical errors notifications are enabled.
		if (
			self::OMS_NOTIFY_ADMIN['enabled'] &&
			self::OMS_NOTIFY_ADMIN['notification_types']['critical_errors']
		) {
			$admin_email = get_option( 'admin_email' );
			$site_name   = get_bloginfo( 'name' );

			$subject = 'Critical Security Alert - ' . get_bloginfo( 'name' );
			$body    = sprintf(
				"Critical security issue detected:\n\nError ID: %s\nTime: %s\nMessage: %s\n%s",
				uniqid( 'OMS_ERR_' ),
				$timestamp,
				$message,
				self::OMS_NOTIFY_ADMIN['include_context'] ? "\nContext: " . $caller : ''
			);

			wp_mail( $admin_email, $subject, $body );

			// Store in database for audit trail.
			if ( function_exists( 'update_option' ) ) {
				$audit_log   = get_option( 'oms_security_audit_log', array() );
				$audit_log[] = array(
					'timestamp' => $timestamp,
					'level'     => 'CRITICAL',
					'message'   => $message,
					'caller'    => $caller,
				);

				// Keep only last 100 entries.
				if ( count( $audit_log ) > 100 ) {
					$audit_log = array_slice( $audit_log, -100 );
				}

				update_option( 'oms_security_audit_log', $audit_log );
			}
		}

		// Perform cleanup if necessary.
		if ( isset( $context['cleanup_required'] ) && $context['cleanup_required'] ) {
			$this->run_full_cleanup( $context );
		}
	}

	/**
	 * Calculate optimal chunk size.
	 *
	 * @return int Optimal chunk size in bytes.
	 */
	public function calculate_optimal_chunk_size() {
		try {
			$memory_limit = $this->get_memory_limit();

			// Get available memory.
			$available_memory = $this->get_available_memory();

			// Get disk space.
			$available_disk_space = disk_free_space( ABSPATH );

			// Calculate base chunk size (20% of available memory).
			$base_chunk_size = (int) ( $available_memory * 0.2 );

			// Apply constraints.
			$min_chunk_size = 1024 * 1024;      // 1MB minimum.
			$max_chunk_size = 5 * 1024 * 1024;  // 5MB maximum.

			// Adjust based on available disk space.
			if ( $available_disk_space < $base_chunk_size * 10 ) {
				$base_chunk_size = (int) ( $available_disk_space * 0.1 );
			}

			// Ensure chunk size is within bounds.
			$chunk_size = max( $min_chunk_size, min( $base_chunk_size, $max_chunk_size ) );

			$this->logger->info(
				sprintf(
					'Calculated optimal chunk size: %d bytes (Memory: %d, Disk: %d)',
					$chunk_size,
					$available_memory,
					$available_disk_space
				)
			);

			return $chunk_size;
		} catch ( Exception $e ) {
			$this->logger->error( 'Error calculating chunk size: ' . esc_html( $e->getMessage() ) );
			return 1024 * 1024; // Return 1MB as safe default.
		}
	}

	/**
	 * Get memory limit.
	 *
	 * @return int Memory limit in bytes.
	 */
	private function get_memory_limit() {
		$memory_limit = ini_get( 'memory_limit' );
		if ( '-1' === $memory_limit ) {
			return PHP_INT_MAX;
		}

		if ( preg_match( '/^(\d+)(.)$/', $memory_limit, $matches ) ) {
			$value = (int) $matches[1];
			$unit  = strtolower( $matches[2] );
			switch ( $unit ) {
				case 'g':
					$value *= 1024;
					// Fall through.
				case 'm':
					$value *= 1024;
					// Fall through.
				case 'k':
					$value *= 1024;
			}
			return $value;
		}

		return 128 * 1024 * 1024; // 128MB default.
	}

	/**
	 * Get available memory.
	 *
	 * @return int Available memory in bytes.
	 */
	private function get_available_memory() {
		$memory_limit     = $this->get_memory_limit();
		$memory_usage     = memory_get_usage( true );
		$available_memory = $memory_limit - $memory_usage;

		return max( 0, $available_memory );
	}

	/**
	 * Check if should throttle.
	 *
	 * @return bool True if should throttle.
	 */
	public function should_throttle() {
		try {
			// Check if rate limiting is enabled.
			if ( ! defined( 'OMS_RATE_LIMIT_ENABLED' ) ) {
				define( 'OMS_RATE_LIMIT_ENABLED', true );
			}

			if ( ! OMS_RATE_LIMIT_ENABLED ) {
				return false;
			}

			// Check server load.
			if ( function_exists( 'sys_getloadavg' ) ) {
				$load     = sys_getloadavg();
				$max_load = OMS_Config::RATE_LIMIT_CONFIG['max_cpu_load'];

				if ( $load[0] > $max_load ) {
					$this->logger->warning( sprintf( 'High server load detected: %.2f', $load[0] ) );
					return true;
				}
			}

			// Check memory usage.
			$memory_usage       = memory_get_usage( true );
			$memory_limit       = $this->get_memory_limit();
			$max_memory_percent = OMS_Config::RATE_LIMIT_CONFIG['max_memory_percent'];

			if ( ( $memory_usage / $memory_limit ) * 100 > $max_memory_percent ) {
				$this->logger->warning(
					sprintf(
						'High memory usage detected: %.2f%%',
						( $memory_usage / $memory_limit ) * 100
					)
				);
				return true;
			}

			// Check request rate.
			$request_key   = 'oms_request_count_' . gmdate( 'Y-m-d-H' );
			$request_count = (int) get_transient( $request_key );
			$max_requests  = OMS_Config::RATE_LIMIT_CONFIG['requests_per_hour'];

			if ( $request_count > $max_requests ) {
				$this->logger->warning( 'Request limit exceeded for current hour' );
				return true;
			}

			// Increment request count.
			set_transient( $request_key, $request_count + 1, HOUR_IN_SECONDS );

			// Check peak hours.
			$hour       = (int) current_time( 'G' );
			$peak_start = OMS_Config::RATE_LIMIT_CONFIG['peak_hour_start'];
			$peak_end   = OMS_Config::RATE_LIMIT_CONFIG['peak_hour_end'];

			if ( $hour >= $peak_start && $hour <= $peak_end ) {
				// During peak hours, be more conservative.
				if ( function_exists( 'sys_getloadavg' ) ) {
					$load     = sys_getloadavg();
					$max_load = OMS_Config::RATE_LIMIT_CONFIG['max_cpu_load'];
					if ( $load[0] > $max_load * 0.8 ) {
						$this->logger->info( 'Throttling during peak hours' );
						return true;
					}
				}
			}

			return false;
		} catch ( Exception $e ) {
			$this->logger->error( 'Error in throttle check: ' . $e->getMessage() );
			return true; // Throttle on error to be safe.
		}
	}

	/**
	 * Extract match context.
	 *
	 * @param string $file File path.
	 * @param string $pattern Pattern.
	 * @return array Match context.
	 * @throws Exception If file cannot be read.
	 */
	public function extract_match_context( $file, $pattern ) {
		$this->logger->info( 'Extracting context for pattern matches in: ' . esc_html( $file ) );

		try {
			if ( ! file_exists( $file ) || ! is_readable( $file ) ) {
				throw new Exception( 'File not accessible: ' . esc_html( $file ) );
			}

			// Read file content in chunks to handle large files.
			$handle = fopen( $file, 'r' );
			if ( false === $handle ) {
				throw new Exception( 'Failed to open file: ' . esc_html( $file ) );
			}

			$matches       = array();
			$line_number   = 0;
			$context_lines = 3; // Number of lines before and after match.
			$buffer        = array();

			// Read file line by line.
			while ( ! feof( $handle ) ) {
				$line = fgets( $handle );
				if ( false === $line ) {
					break;
				}

				++$line_number;

				// Keep a rolling buffer of recent lines.
				$buffer[] = array(
					'number'  => $line_number,
					'content' => rtrim( $line ),
				);

				// Keep only necessary lines in buffer.
				if ( count( $buffer ) > $context_lines * 2 + 1 ) {
					array_shift( $buffer );
				}

				// Check for pattern match.
				if ( preg_match( $pattern, $line ) ) {
					// Calculate context range.
					$context_start = max( 0, count( $buffer ) - $context_lines - 1 );
					$context       = array_slice( $buffer, $context_start );

					// Store match with context.
					$matches[] = array(
						'line'    => $line_number,
						'context' => $context,
						'match'   => trim( $line ),
					);

					// Log the match.
					$this->logger->warning(
						sprintf(
							'Found match in %s on line %d: %s',
							$file,
							$line_number,
							substr( trim( $line ), 0, 100 ) . ( strlen( $line ) > 100 ? '...' : '' )
						)
					);
				}
			}

			fclose( $handle );

			// Format the output.
			$output = array();
			foreach ( $matches as $match ) {
				$context_str = "Match on line {$match['line']}:\n";
				foreach ( $match['context'] as $context_line ) {
					$prefix       = $context_line['number'] === $match['line'] ? '>' : ' ';
					$context_str .= sprintf(
						"%s %4d: %s\n",
						$prefix,
						$context_line['number'],
						$this->sanitize_output( $context_line['content'] )
					);
				}
				$output[] = $context_str;
			}

			return array(
				'file'     => $file,
				'pattern'  => $pattern,
				'matches'  => count( $matches ),
				'contexts' => $output,
			);
		} catch ( Exception $e ) {
			$this->logger->error( 'Error extracting match context: ' . $e->getMessage() );
			return array(
				'file'     => $file,
				'pattern'  => $pattern,
				'matches'  => 0,
				'contexts' => array(),
				'error'    => $e->getMessage(),
			);
		}
	}

	/**
	 * Sanitize output.
	 *
	 * @param string $content Content to sanitize.
	 * @return string Sanitized content.
	 */
	private function sanitize_output( $content ) {
		// Remove null bytes and control characters.
		$content = str_replace( "\0", '', $content );
		$content = preg_replace( '/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/', '', $content );

		// Encode special characters for safe display.
		return htmlspecialchars( $content, ENT_QUOTES, 'UTF-8' );
	}

	/**
	 * Return basic status information for the admin screen.
	 *
	 * @return array Status information.
	 */
	public function get_status() {
		return array(
			'last_scan'     => get_option( 'oms_last_scan', 'never' ),
			'files_scanned' => (int) get_option( 'oms_files_scanned', 0 ),
			'issues_found'  => (int) get_option( 'oms_issues_found', 0 ),
			'issues'        => array(),
		);
	}
}
