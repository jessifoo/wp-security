<?php
declare(strict_types=1);

/**
 * Main Scanner class for malware detection.
 *
 * This class orchestrates malware scanning operations. All dependencies
 * are injected via constructor for testability and clean architecture.
 *
 * @package ObfuscatedMalwareScanner
 * @since   2.0.0
 */

// If this file is called directly, abort.
if ( ! defined( 'ABSPATH' ) ) {
	die( 'Direct access is not allowed.' );
}

/**
 * Main Scanner class.
 *
 * Coordinates scanning operations by delegating to specialized services.
 * This class follows the Facade pattern - it provides a simple interface
 * to the complex subsystem of scanners, validators, and managers.
 */
class Obfuscated_Malware_Scanner {

	/**
	 * Rate limit for scan operations.
	 */
	public const int RATE_LIMITS = 5;

	/**
	 * Admin notification settings.
	 *
	 * @var array<string, mixed>
	 */
	public const array NOTIFY_SETTINGS = array(
		'enabled'                    => true,
		'severity_threshold'         => 'warning',
		'batch_interval'             => 3600,
		'max_notifications_per_hour' => 10,
		'include_context'            => true,
	);

	/**
	 * Verified core files cache.
	 *
	 * @var array<string>
	 */
	private array $verified_core_files = array();

	/**
	 * Constructor with dependency injection.
	 *
	 * @param OMS_Logger                 $logger            Logger service.
	 * @param OMS_Cache                  $cache             Cache service.
	 * @param OMS_Rate_Limiter           $rate_limiter      Rate limiter service.
	 * @param OMS_Filesystem             $filesystem        Filesystem service.
	 * @param OMS_File_Security_Policy   $security_policy   Security policy service.
	 * @param OMS_Quarantine_Manager     $quarantine_manager Quarantine manager.
	 * @param OMS_Core_Integrity_Checker $integrity_checker Core integrity checker.
	 * @param OMS_Database_Scanner       $database_scanner  Database scanner.
	 */
	public function __construct(
		private readonly OMS_Logger $logger,
		// phpcs:ignore Generic.Commenting -- PHPStan directive.
		/** @phpstan-ignore property.onlyWritten */
		private readonly OMS_Cache $cache,
		private readonly OMS_Rate_Limiter $rate_limiter,
		// phpcs:ignore Generic.Commenting -- PHPStan directive.
		/** @phpstan-ignore property.onlyWritten */
		private readonly OMS_Filesystem $filesystem,
		private readonly OMS_File_Security_Policy $security_policy,
		private readonly OMS_Quarantine_Manager $quarantine_manager,
		private readonly OMS_Core_Integrity_Checker $integrity_checker,
		private readonly OMS_Database_Scanner $database_scanner,
	) {
		$this->logger->info( 'Scanner initialized' );
	}

	/**
	 * Register WordPress hooks for scanning operations.
	 *
	 * Called during plugin initialization to set up event handlers.
	 *
	 * @return void
	 */
	public function register_hooks(): void {
		add_action( 'oms_daily_cleanup', array( $this, 'run_full_cleanup' ) );
		add_action( 'added_post_meta', array( $this, 'check_uploaded_file' ), 10, 4 );
		add_filter( 'upload_dir', array( $this, 'sanitize_upload_path' ) );
	}

	/**
	 * Run a complete security scan and cleanup.
	 *
	 * This is the main entry point for scheduled and manual scans.
	 * It coordinates all scanning operations in the correct order.
	 *
	 * @return void
	 */
	public function run_full_cleanup(): void {
		$this->logger->info( 'Starting full security scan' );

		try {
			// 1. Verify WordPress core files first.
			$this->scan_core_files();

			// 2. Scan plugin files.
			$this->scan_directory( $this->get_plugin_dir(), 'plugins' );

			// 3. Scan theme files.
			$this->scan_directory( $this->get_theme_dir(), 'themes' );

			// 4. Scan uploads directory.
			$this->scan_directory( $this->get_uploads_dir(), 'uploads' );

			// 5. Clean up old quarantined files.
			$this->cleanup_quarantine();

			// 6. Check and fix file permissions.
			$this->check_file_permissions();

			// 7. Scan database for malicious content.
			$this->scan_database();

			// Update scan stats.
			update_option( 'oms_last_scan', current_time( 'mysql' ) );

			$this->logger->info( 'Full security scan completed' );

		} catch ( Exception $e ) {
			$this->logger->error( 'Security scan failed: ' . $e->getMessage() );
			$this->notify_admin_of_error( $e );
		}
	}

	/**
	 * Get scanner status for admin display.
	 *
	 * @return array{last_scan: string, files_scanned: int, issues_found: int, issues: array<mixed>}
	 */
	public function get_status(): array {
		return array(
			'last_scan'     => (string) get_option( 'oms_last_scan', 'never' ),
			'files_scanned' => (int) get_option( 'oms_files_scanned', 0 ),
			'issues_found'  => (int) get_option( 'oms_issues_found', 0 ),
			'issues'        => (array) get_option( 'oms_detected_issues', array() ),
		);
	}

	/**
	 * Get log directory path.
	 *
	 * @return string Log directory path.
	 */
	public function get_log_path(): string {
		$log_path = OMS_Config::LOG_CONFIG['path'];
		$this->ensure_directory_protected( $log_path );
		return $log_path;
	}

	/**
	 * Check if a file contains malware patterns.
	 *
	 * @param string $path File path to check.
	 * @return bool True if malware detected.
	 */
	public function contains_malware( string $path ): bool {
		if ( ! file_exists( $path ) || ! is_readable( $path ) ) {
			$this->logger->warning( 'File not accessible: ' . esc_html( $path ) );
			return true; // Treat inaccessible files as suspicious.
		}

		$filesize = filesize( $path );
		if ( false === $filesize || 0 === $filesize ) {
			return true; // Empty or unreadable files are suspicious.
		}

		// Check for PHP code in binary files.
		if ( $this->is_binary_file( $path ) && $this->contains_php_in_binary( $path ) ) {
			$this->logger->error( 'PHP code in binary file: ' . esc_html( $path ) );
			return true;
		}

		// Check against malware patterns.
		return $this->matches_malware_patterns( $path );
	}

	/**
	 * Quarantine a suspicious file.
	 *
	 * @param string $file_path Path to file.
	 * @return bool True if quarantine succeeded.
	 */
	public function quarantine_file( string $file_path ): bool {
		// Never quarantine core WordPress files.
		if ( $this->is_core_file( $file_path ) ) {
			$this->logger->error( 'Attempted to quarantine core file: ' . esc_html( $file_path ) );
			return false;
		}

		return $this->quarantine_manager->quarantine_file( $file_path );
	}

	/**
	 * Check uploaded file for malware.
	 *
	 * Hooked to 'added_post_meta' action.
	 *
	 * @param int    $meta_id    Meta ID.
	 * @param int    $post_id    Post ID.
	 * @param string $meta_key   Meta key.
	 * @param mixed  $meta_value Meta value.
	 * @return void
	 */
	public function check_uploaded_file( int $meta_id, int $post_id, string $meta_key, mixed $meta_value ): void {
		if ( '_wp_attached_file' !== $meta_key ) {
			return;
		}

		$upload_dir = wp_upload_dir();
		if ( ! isset( $upload_dir['basedir'] ) || ! is_string( $upload_dir['basedir'] ) ) {
			$this->logger->error( 'Invalid upload directory configuration' );
			return;
		}

		try {
			$file_path = OMS_Utils::sanitize_path(
				$upload_dir['basedir'] . '/' . (string) $meta_value
			);

			$validation = $this->security_policy->validate_file( $file_path );

			if ( ! $validation['valid'] || $this->contains_malware( $file_path ) ) {
				$this->quarantine_file( $file_path );
				wp_delete_attachment( $post_id, true );
				$this->logger->warning( 'Malicious upload quarantined: ' . esc_html( $file_path ) );
			}
		} catch ( InvalidArgumentException $e ) {
			$this->logger->error( 'Invalid upload path: ' . $e->getMessage() );
		} catch ( OMS_Security_Exception $e ) {
			$this->logger->error( 'Security violation: ' . $e->getMessage() );
		}
	}

	/**
	 * Sanitize upload directory paths.
	 *
	 * Hooked to 'upload_dir' filter.
	 *
	 * @param array<string, mixed> $upload_dir Upload directory data.
	 * @return array<string, mixed> Sanitized upload directory data.
	 */
	public function sanitize_upload_path( array $upload_dir ): array {
		if ( ! empty( $upload_dir['error'] ) ) {
			return $upload_dir;
		}

		foreach ( array( 'path', 'basedir' ) as $key ) {
			if ( isset( $upload_dir[ $key ] ) && is_string( $upload_dir[ $key ] ) ) {
				$normalized = wp_normalize_path( $upload_dir[ $key ] );

				if ( ! OMS_Utils::is_path_safe( $normalized ) ) {
					$this->logger->warning( 'Path traversal detected: ' . esc_html( $upload_dir[ $key ] ) );
					$upload_dir['error'] = __( 'Invalid upload path detected.', 'obfuscated-malware-scanner' );
					return $upload_dir;
				}

				$upload_dir[ $key ] = $normalized;
			}
		}

		return $upload_dir;
	}

	/**
	 * Scan database for malicious content.
	 *
	 * @return array{success: bool, total?: int, message?: string}
	 */
	public function scan_database(): array {
		$this->logger->info( 'Starting database scan' );
		$result = $this->database_scanner->scan_database();

		$total = isset( $result['total'] ) ? (int) $result['total'] : 0;
		if ( $result['success'] && $total > 0 ) {
			$this->logger->warning( sprintf( 'Database scan found %d issues', $total ) );
			// @phpstan-ignore-next-line Key may not exist in error case.
			$this->store_pending_issues( (array) ( $result['issues'] ?? array() ) );
		}

		return $result;
	}

	// =========================================================================
	// Private Methods
	// =========================================================================

	/**
	 * Scan WordPress core files for modifications.
	 *
	 * @return void
	 */
	private function scan_core_files(): void {
		$this->logger->info( 'Verifying core files' );

		$results = $this->integrity_checker->verify_core_files();

		if ( isset( $results['error'] ) ) {
			$this->logger->error( 'Core verification failed: ' . $results['error'] );
			return;
		}

		$this->verified_core_files = $results['safe'];

		foreach ( $results['modified'] as $file ) {
			$this->logger->warning( 'Modified core file: ' . esc_html( $file ) );
		}

		foreach ( $results['missing'] as $file ) {
			$this->logger->warning( 'Missing core file: ' . esc_html( $file ) );
		}
	}

	/**
	 * Scan a directory for malicious files.
	 *
	 * @param string $directory Directory path.
	 * @param string $context   Context name for logging.
	 * @return void
	 */
	private function scan_directory( string $directory, string $context ): void {
		if ( ! is_dir( $directory ) ) {
			$this->logger->warning( "Directory not found: {$directory}" );
			return;
		}

		$this->logger->info( "Scanning {$context} directory" );

		try {
			$iterator = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator( $directory, RecursiveDirectoryIterator::SKIP_DOTS )
			);

			foreach ( $iterator as $file ) {
				if ( ! $file->isFile() ) {
					continue;
				}

				$path = $file->getPathname();

				// Skip verified core files.
				if ( $this->is_verified_core_file( $path ) ) {
					continue;
				}

				// Rate limit to prevent server overload.
				if ( $this->rate_limiter->should_throttle() ) {
					usleep( OMS_Config::SCAN_CONFIG['batch_pause'] * 1000 );
				}

				$validation = $this->security_policy->validate_file( $path );
				if ( ! $validation['valid'] ) {
					$this->logger->warning( "Suspicious file in {$context}: " . esc_html( $path ) );
					$this->quarantine_file( $path );
				}
			}
		} catch ( Exception $e ) {
			$this->logger->error( "Error scanning {$context}: " . $e->getMessage() );
		}

		$this->logger->info( "Completed scanning {$context}" );
	}

	/**
	 * Clean up old quarantined files.
	 *
	 * @return void
	 */
	private function cleanup_quarantine(): void {
		$quarantine_path = OMS_Config::QUARANTINE_CONFIG['path'];
		$retention_days  = OMS_Config::QUARANTINE_CONFIG['retention_days'];

		if ( ! is_dir( $quarantine_path ) ) {
			return;
		}

		$cutoff = strtotime( "-{$retention_days} days" );

		$iterator = new RecursiveIteratorIterator(
			new RecursiveDirectoryIterator( $quarantine_path, RecursiveDirectoryIterator::SKIP_DOTS )
		);

		foreach ( $iterator as $file ) {
			if ( $file->getMTime() < $cutoff ) {
				wp_delete_file( $file->getPathname() );
			}
		}
	}

	/**
	 * Check and fix file permissions.
	 *
	 * @return void
	 */
	private function check_file_permissions(): void {
		$this->logger->info( 'Checking file permissions' );

		$secure_file_perms = OMS_Config::SCAN_CONFIG['allowed_permissions']['file'];
		$secure_dir_perms  = OMS_Config::SCAN_CONFIG['allowed_permissions']['dir'];

		$directories = array(
			ABSPATH,
			WP_CONTENT_DIR,
			WP_CONTENT_DIR . '/uploads',
		);

		foreach ( $directories as $dir ) {
			if ( ! is_dir( $dir ) ) {
				continue;
			}

			$iterator = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator( $dir, RecursiveDirectoryIterator::SKIP_DOTS )
			);

			foreach ( $iterator as $item ) {
				$path  = $item->getPathname();
				$perms = fileperms( $path ) & 0777;

				$target = $item->isDir() ? $secure_dir_perms : $secure_file_perms;

				if ( $perms !== $target ) {
					// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_chmod
					if ( chmod( $path, $target ) ) {
						$this->logger->info( 'Fixed permissions: ' . esc_html( $path ) );
					}
				}
			}
		}
	}

	/**
	 * Check if file matches malware patterns.
	 *
	 * @param string $path File path.
	 * @return bool True if matches malware patterns.
	 */
	private function matches_malware_patterns( string $path ): bool {
		$content = file_get_contents( $path );
		if ( false === $content ) {
			return false;
		}

		// Check obfuscation patterns.
		foreach ( OMS_Config::OBFUSCATION_PATTERNS as $pattern ) {
			if ( preg_match( '/' . $pattern['pattern'] . '/i', $content ) ) {
				$this->logger->warning( 'Malware pattern matched: ' . esc_html( $pattern['description'] ) );
				return true;
			}
		}

		// Check standard malware patterns.
		foreach ( OMS_Config::MALWARE_PATTERNS as $pattern ) {
			if ( preg_match( $pattern['pattern'], $content ) ) {
				$this->logger->warning( 'Malware detected: ' . esc_html( $pattern['description'] ) );
				return true;
			}
		}

		return false;
	}

	/**
	 * Check if file is a binary type.
	 *
	 * @param string $path File path.
	 * @return bool True if binary file.
	 */
	private function is_binary_file( string $path ): bool {
		$extension = strtolower( pathinfo( $path, PATHINFO_EXTENSION ) );
		return in_array( $extension, array( 'jpg', 'jpeg', 'png', 'gif', 'pdf', 'zip' ), true );
	}

	/**
	 * Check if binary file contains PHP code.
	 *
	 * @param string $path File path.
	 * @return bool True if PHP code found.
	 */
	private function contains_php_in_binary( string $path ): bool {
		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fopen
		$handle = fopen( $path, 'rb' );
		if ( false === $handle ) {
			return false;
		}

		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fread
		$content = fread( $handle, 1024 );
		// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_fclose
		fclose( $handle );

		return false !== $content && 1 === preg_match( '/<\?php|<\?=/i', $content );
	}

	/**
	 * Check if file is a verified core file.
	 *
	 * @param string $path File path.
	 * @return bool True if verified core file.
	 */
	private function is_verified_core_file( string $path ): bool {
		return $this->integrity_checker->is_verified_core_file( $path, $this->verified_core_files );
	}

	/**
	 * Check if file is a WordPress core file.
	 *
	 * @param string $path File path.
	 * @return bool True if core file.
	 */
	private function is_core_file( string $path ): bool {
		$normalized = wp_normalize_path( $path );
		$wp_content = wp_normalize_path( WP_CONTENT_DIR );

		// If not in wp-content, might be core.
		if ( false === strpos( $normalized, $wp_content ) ) {
			$basename = basename( $path );
			return in_array( $basename, OMS_Config::CRITICAL_FILES, true );
		}

		return in_array( $path, $this->verified_core_files, true );
	}

	/**
	 * Ensure directory exists and is protected.
	 *
	 * @param string $path Directory path.
	 * @return void
	 */
	private function ensure_directory_protected( string $path ): void {
		if ( ! is_dir( $path ) ) {
			wp_mkdir_p( $path );
		}

		$htaccess = $path . '/.htaccess';
		if ( ! file_exists( $htaccess ) ) {
			// phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_operations_file_put_contents
			file_put_contents( $htaccess, "Order deny,allow\nDeny from all\n" );
		}
	}

	/**
	 * Store pending database issues.
	 *
	 * @param array<mixed> $issues Issues to store.
	 * @return void
	 */
	private function store_pending_issues( array $issues ): void {
		update_option(
			'oms_pending_db_issues',
			array(
				'timestamp' => time(),
				'issues'    => $issues,
			),
			false
		);
	}

	/**
	 * Notify admin of a critical error.
	 *
	 * @param Exception $e The exception.
	 * @return void
	 */
	private function notify_admin_of_error( Exception $e ): void {
		if ( ! get_option( 'oms_email_notifications', true ) ) {
			return;
		}

		$admin_email = get_option( 'admin_email' );
		if ( ! $admin_email ) {
			return;
		}

		wp_mail(
			$admin_email,
			sprintf( '[%s] Security Scan Error', get_bloginfo( 'name' ) ),
			sprintf(
				"A security scan error occurred:\n\nError: %s\nTime: %s\n",
				$e->getMessage(),
				current_time( 'mysql' )
			)
		);
	}

	/**
	 * Get plugin directory path.
	 *
	 * @return string Plugin directory path.
	 */
	private function get_plugin_dir(): string {
		return defined( 'WP_PLUGIN_DIR' ) ? WP_PLUGIN_DIR : '';
	}

	/**
	 * Get theme directory path.
	 *
	 * @return string Theme directory path.
	 */
	private function get_theme_dir(): string {
		return defined( 'WP_CONTENT_DIR' ) ? WP_CONTENT_DIR . '/themes' : '';
	}

	/**
	 * Get uploads directory path.
	 *
	 * @return string Uploads directory path.
	 */
	private function get_uploads_dir(): string {
		return defined( 'WP_CONTENT_DIR' ) ? WP_CONTENT_DIR . '/uploads' : '';
	}

	// =========================================================================
	// Legacy API Compatibility
	// =========================================================================

	/**
	 * Set security policy (for testing).
	 *
	 * @param OMS_File_Security_Policy $policy Security policy.
	 * @return void
	 */
	public function set_security_policy( OMS_File_Security_Policy $policy ): void {
		// No-op: dependencies are now readonly. Use OMS_Container::set() for testing.
	}

	/**
	 * Set logger (for testing).
	 *
	 * @param OMS_Logger $logger Logger instance.
	 * @return void
	 */
	public function set_logger( OMS_Logger $logger ): void {
		// No-op: dependencies are now readonly. Use OMS_Container::set() for testing.
	}
}
