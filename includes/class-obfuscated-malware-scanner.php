<?php
/**
 * Main plugin class for malware scanner
 *
 * @package ObfuscatedMalwareScanner
 */

// If this file is called directly, abort.
if ( ! defined( 'ABSPATH' ) ) {
	die( 'Direct access is not allowed.' );
}

require_once __DIR__ . '/class-oms-config.php';
require_once __DIR__ . '/class-oms-logger.php';
require_once __DIR__ . '/class-oms-utils.php';
require_once __DIR__ . '/class-oms-exception.php';

/**
 * Main plugin class.
 */
class Obfuscated_Malware_Scanner {
	/** @var OMS_Logger */
	private $logger;

	/** @var OMS_Exception */
	private $exception;

	/** @var array */
	private $compiledPatterns;

	const RATE_LIMITS = 5; // Define RATE_LIMITS constant.
	const BACKDOOR_PATTERNS = array(); // Define BACKDOOR_PATTERNS constant.
	/**
	 * Admin notification settings
	 */
	const OMS_NOTIFY_ADMIN = array(
		'enabled'                  => true,
		'severity_threshold'       => 'warning',  // Minimum severity level to notify.
		'batch_interval'          => 3600,      // Seconds between notification batches.
		'max_notifications_per_hour' => 10,      // Prevent notification flood.
		'include_context'          => true,       // Include surrounding code context.
		'notification_types'      => array(
			'malware_detected'   => true,
			'zero_byte_files'    => true,
			'permission_changes' => true,
			'critical_errors'    => true,
			'quarantine_actions' => true,
		),
	);

	private $cache;
	private $rateLimiter;
	private $securityPolicy;
	private $scanner;

	public function __construct() {
		try {
			$this->logger           = new OMS_Logger();
			$this->compiledPatterns = $this->loadOrCompilePatterns();
			$this->logger->info( 'Scanner initialized successfully' );
		} catch ( OMS_Exception $e ) {
			// Log initialization error but don't throw to prevent breaking site.
			error_log( 'OMS initialization failed: ' . $e->getMessage() );
		}
	}

	/**
	 * Initialize the plugin.
	 */
	public function init() {
		try {
			$this->setupHooks();
			$this->logger->info( 'Plugin hooks initialized successfully' );
		} catch ( OMS_Exception $e ) {
			$this->handleException( $e, 'Failed to initialize plugin hooks' );
		}
	}

	/**
	 * Set up WordPress hooks and filters.
	 *
	 * @throws OMS_Exception
	 */
	private function setupHooks() {
		if ( ! function_exists( 'register_activation_hook' ) ) {
			throw new OMS_Exception( 'WordPress functions not available' );
		}

		register_activation_hook( plugin_basename( __FILE__ ), array( $this, 'runFullCleanup' ) );

		if ( ! wp_next_scheduled( 'oms_daily_cleanup' ) ) {
			wp_schedule_event( time(), 'daily', 'oms_daily_cleanup' );
		}

		add_action( 'oms_daily_cleanup', array( $this, 'runFullCleanup' ) );
		add_action( 'added_post_meta', array( $this, 'checkUploadedFile' ), 10, 4 );
		add_filter( 'upload_dir', array( $this, 'sanitizeUploadPath' ) );
	}

	/**
	 * Load or compile malware patterns.
	 *
	 * @return array Compiled patterns
	 * @throws OMS_Exception
	 */
	private function loadOrCompilePatterns() {
		try {
			$patterns = array_merge(
				OMS_Config::OBFUSCATION_PATTERNS,
				OMS_Config::MALWARE_PATTERNS
			);

			$compiled = array();
			foreach ( $patterns as $pattern ) {
				if ( false === @preg_match( '#' . $pattern['pattern'] . '#i', '' ) ) {
					$this->logger->warning( 'Invalid pattern skipped: ' . $pattern['pattern'] );
					continue;
				}
				$compiled[] = array(
					'pattern'     => '#' . $pattern['pattern'] . '#i',
					'severity'    => $pattern['severity'],
					'description' => $pattern['description'],
				);
			}

			return $compiled;
		} catch ( Exception $e ) {
			throw new OMS_Exception( 'Failed to compile patterns: ' . $e->getMessage() );
		}
	}

	/**
	 * Perform a full cleanup of the site.
	 */
	public function runFullCleanup() {
		try {
			$this->logger->info('Starting full cleanup');
			$this->cleanupCoreFiles();
			$this->cleanupPlugins();
			$this->cleanupUploads();
			$this->cleanupQuarantine();
			$this->checkFilePermissions();
			$this->logger->info('Full cleanup completed successfully');
		} catch (Exception $e) {
			$this->handleException($e, 'Full cleanup failed');
		}
	}

	/**
	 * Cleanup WordPress core files.
	 */
	private function cleanupCoreFiles()
	{
		try {
			$checksums = $this->getCoreChecksums();
			foreach ($checksums as $file => $checksum) {
				$this->processCoreFile($file, $checksum);
			}
		} catch (Exception $e) {
			$this->handleException($e, 'Core file cleanup failed');
		}
	}

	private function processCoreFile($file, $checksum)
	{
		$filePath = OMS_Utils::sanitize_path(ABSPATH . $file);

		if (! OMS_Utils::is_path_safe($filePath)) {
			$this->logger->warning("Skipping unsafe path: $filePath");
			return;
		}

		if (! is_readable($filePath)) {
			$this->downloadCoreFile($file);
			return;
		}

		$fileHash = md5_file( $filePath );
		if ( $checksum !== $fileHash ) {
			$this->logger->warning( "Checksum mismatch for: $filePath" );
			$this->downloadCoreFile( $file );
		}
	}

	private function downloadCoreFile( $file, $retry = 3 ) {
		$url         = sprintf( 'https://core.svn.wordpress.org/tags/%s/%s', get_bloginfo( 'version' ), $file );
		$destination = ABSPATH . $file;

		while ( $retry-- > 0 ) {
			if ( $this->downloadFile( $url, $destination ) ) {
				$this->logger->info( 'Downloaded core file', array( 'file' => $file ) );
				return true;
			}
			sleep( 2 ); // Backoff delay.
		}
		$this->logger->error( 'Failed to download core file after retries', array( 'file' => $file ) );
		return false;
	}

	/**
	 * Validate and sanitize uploaded files.
	 */
	public function checkUploadedFile( $metaId, $postId, $metaKey, $metaValue ) {
		if ( '_wp_attached_file' !== $metaKey ) {
			return;
		}

		$uploadDir = wp_upload_dir();
		$filePath  = OMS_Utils::sanitize_path($uploadDir['basedir'] . '/' . $metaValue);

		if (! $this->securityPolicy->validateFile($filePath)['valid'] || $this->containsMalware($filePath)) {
			$this->quarantineFile($filePath);
			wp_delete_attachment($postId, true);
			$this->logger->warning("Malicious file quarantined: $filePath");
		}
	}

	/**
	 * Scan a file for malware patterns with improved obfuscation detection
	 */
	public function containsMalware($path)
	{
		try {
			if (! file_exists($path) || ! is_readable($path)) {
				$this->logger->warning('File not accessible', array('path' => $path));
				return true; // Treat inaccessible files as suspicious
			}

			// Check file size.
			$filesize = @filesize( $path );
			if ( false === $filesize || 0 === $filesize ) {
				$this->logger->warning( 'Empty or zero-byte file detected', array( 'path' => $path ) );
				return true; // Treat zero-byte files as suspicious.
			}

			// First check for binary files that shouldn't contain PHP
			if ($this->isBinaryFile($path) && $this->containsPhpCode($path)) {
				$this->logger->error('PHP code found in binary file', array('path' => $path));
				return true;
			}

			// Scan with new obfuscation patterns first.
			foreach ( OMS_Config::OBFUSCATION_PATTERNS as $pattern ) {
				if ( $this->matchPattern( $path, $pattern['pattern'] ) ) {
					$this->logger->info(
						$pattern['severity'],
						"Detected {$pattern['description']}",
						array(
							'path'    => $path,
							'pattern' => $pattern['pattern'],
						)
					);
					return true;
				}
			}

			// Then check other malicious patterns
			$chunkSize = $this->calculateOptimalChunkSize();
			return $this->scanFileChunks($path, $chunkSize);
		} catch (Exception $e) {
			$this->handleException($e, "Error scanning file: $path");
			return true; // Treat exceptions as suspicious
		}
	}

	/**
	 * Check if a file is a binary file that shouldn't contain PHP code
	 */
	private function isBinaryFile($path)
	{
		$extension = strtolower(pathinfo($path, PATHINFO_EXTENSION));
		return in_array($extension, array('jpg', 'jpeg', 'png', 'gif', 'pdf', 'zip'));
	}

	/**
	 * Check if a file contains PHP code
	 */
	private function containsPhpCode( $path ) {
		// Read first 1024 bytes to check for PHP signature.
		$handle = fopen( $path, 'rb' );
		if ( false === $handle ) {
			return false;
		}

		$content = fread( $handle, 1024 );
		fclose( $handle );

		return 1 === preg_match( '/<\?php|<\?=|\xFF\xD8\xFF\xE0.*<\?php/s', $content );
	}

	/**
	 * Match a pattern against a file with proper error handling
	 */
	private function matchPattern( $path, $pattern ) {
		try {
			$content = file_get_contents( $path );
			if ( false === $content ) {
				throw new Exception( 'Failed to read file contents' );
			}
			return 1 === preg_match( "/$pattern/i", $content );
		} catch ( Exception $e ) {
			$this->logger->error(
				'Pattern matching failed',
				array(
					'path'    => $path,
					'pattern' => $pattern,
					'error'   => $e->getMessage(),
				)
			);
			return false;
		}
	}

	/**
	 * Scan a file for malware patterns.
	 */
	public function scanFileChunks($filePath, $chunkSize)
	{
		try {
			if (! is_readable($filePath)) {
				throw new Exception("File not readable: $filePath");
			}

			$file_size = filesize( $filePath );
			if ( 0 === $file_size ) {
				$this->logger->warning( "Zero-byte file detected: $filePath", 'warning' );
				return false;
			}

			$handle = fopen( $filePath, 'rb' );
			if ( false === $handle ) {
				throw new Exception( "Failed to open file: $filePath" );
			}

			$matches = array();
			$offset  = 0;
			$overlap = OMS_Config::SCAN_CONFIG['overlap_size']; // Overlap between chunks to catch patterns spanning chunks.
			$suspicious_patterns = $this->getMalwarePatterns();
			$start_time          = microtime( true );
			$last_progress_update = 0;

			while ( ! feof( $handle ) ) {
				// Check for timeout.
				if ( microtime( true ) - $start_time > OMS_Config::SECURITY_CONFIG['max_execution_time'] ) { // 5 minutes timeout.
					throw new Exception( "Scan timeout for file: $filePath" );
				}

				// Throttle if needed.
				if ( $this->shouldThrottle() ) {
					usleep( OMS_Config::SCAN_CONFIG['batch_pause'] * 1000 ); // Pause in milliseconds.
				}

				// Read chunk with overlap.
				$chunk = fread( $handle, $chunkSize + $overlap );
				if ( false === $chunk ) {
					throw new Exception( "Failed to read chunk from file: $filePath" );
				}

				// Update progress every 5%.
				$progress = ( $offset / $fileSize ) * 100;
				if ( $progress - $last_progress_update >= 5 ) {
					$this->logger->info( sprintf( 'Scanning %s: %.1f%% complete', basename( $filePath ), $progress ) );
					$last_progress_update = $progress;
				}

				// Check for malicious patterns.
				foreach ( $suspicious_patterns as $pattern ) {
					if ( preg_match( $pattern['pattern'], $chunk, $pattern_matches, PREG_OFFSET_CAPTURE ) ) {
						$matches[] = array(
							'pattern'     => $pattern['pattern'],
							'description' => $pattern['description'],
							'offset'      => $offset + $pattern_matches[0][1],
							'match'       => $pattern_matches[0][0],
							'context'     => $this->extractMatchContext( $filePath, $pattern['pattern'] ),
						);

						$this->logger->warning(
							sprintf(
								'Found suspicious pattern in %s: %s at offset %d',
								basename( $filePath ),
								$pattern['description'],
								$offset + $pattern_matches[0][1]
							),
							'warning'
						);
					}
				}

				// Move back by overlap amount unless at EOF.
				if ( ! feof( $handle ) ) {
					fseek( $handle, $offset + $chunkSize - $overlap );
				}

				$offset += $chunkSize - $overlap;
			}

			fclose( $handle );

			// Log completion.
			$scan_time = microtime( true ) - $start_time;
			$this->logger->info(
				sprintf(
					'Completed scanning %s in %.2f seconds. Found %d suspicious patterns.',
					basename( $filePath ),
					$scan_time,
					count( $matches )
				),
				'info'
			);

			if ( ! empty( $matches ) ) {
				// Store detailed results for admin review.
				$this->logger->warning( $filePath, $matches );
				return false; // File contains suspicious patterns.
			}

			return true; // File is clean

		} catch (Exception $e) {
			$this->exception->handleException($e, "Error scanning file chunks: $filePath");
			return false;
		}
	}

	private function getMalwarePatterns()
	{
		return OMS_Config::MALWARE_PATTERNS;
	}

	private function getLogPath()
	{
		$logPath = OMS_Config::LOG_CONFIG['path'];
		if (! is_dir($logPath)) {
			wp_mkdir_p($logPath);
			$htaccess = $logPath . '/.htaccess';
			if (! file_exists($htaccess)) {
				file_put_contents($htaccess, 'Deny from all');
			}
		}
		return $logPath;
	}

	private function getQuarantinePath()
	{
		$quarantinePath = OMS_Config::QUARANTINE_CONFIG['path'];
		if (! is_dir($quarantinePath)) {
			wp_mkdir_p($quarantinePath);
			$htaccess = $quarantinePath . '/.htaccess';
			if (! file_exists($htaccess)) {
				file_put_contents($htaccess, 'Deny from all');
			}
		}
		return $quarantinePath;
	}

	private function isValidLogLevel($level)
	{
		return in_array(strtolower($level), OMS_Config::LOG_CONFIG['levels']);
	}

	private function enforceExecutionLimits()
	{
		@ini_set('max_execution_time', OMS_Config::SECURITY_CONFIG['max_execution_time']);
		@ini_set('memory_limit', OMS_Config::SECURITY_CONFIG['memory_limit']);
		@ini_set('max_input_time', OMS_Config::SECURITY_CONFIG['max_input_time']);
		@ini_set('max_input_vars', OMS_Config::SECURITY_CONFIG['max_input_vars']);
		@ini_set('post_max_size', OMS_Config::SECURITY_CONFIG['post_max_size']);
		@ini_set('upload_max_filesize', OMS_Config::SECURITY_CONFIG['upload_max_filesize']);
	}

	private function isExcludedPath($path)
	{
		$basename = basename($path);
		if (in_array($basename, OMS_Config::SCAN_CONFIG['excluded_files'])) {
			return true;
		}

		foreach (OMS_Config::SCAN_CONFIG['excluded_dirs'] as $dir) {
			if (strpos($path, "/$dir/") !== false) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Quarantine a file with fallback options and safety checks.
	 *
	 * @param string $path Path to the file to quarantine
	 * @return bool True if quarantine succeeded, false otherwise
	 */
	private function quarantineFile($path)
	{
		try {
			$quarantineDir = OMS_Config::QUARANTINE_CONFIG['path'];

			// Ensure quarantine directory exists and is writable
			if (! file_exists($quarantineDir)) {
				if (! @mkdir($quarantineDir, 0755, true)) {
					throw new Exception('Failed to create quarantine directory');
				}
			}

			if (! is_writable($quarantineDir)) {
				throw new Exception('Quarantine directory is not writable');
			}

			// Generate unique quarantine filename
			$timestamp      = date('Y-m-d_H-i-s');
			$uniqueId       = uniqid();
			$quarantinePath = sprintf(
				'%s/%s_%s_%s.quarantine',
				$quarantineDir,
				pathinfo($path, PATHINFO_FILENAME),
				$timestamp,
				$uniqueId
			);

			// Try primary quarantine method (rename)
			if (@rename($path, $quarantinePath)) {
				$this->logger->info(
					'File quarantined successfully',
					array(
						'original_path'   => $path,
						'quarantine_path' => $quarantinePath,
						'method'          => 'rename',
					)
				);
				return true;
			}

			// Fallback 1: Try copy and delete
			if (@copy($path, $quarantinePath)) {
				if (@unlink($path)) {
					$this->logger->info(
						'File quarantined using copy/delete',
						array(
							'original_path'   => $path,
							'quarantine_path' => $quarantinePath,
							'method'          => 'copy_delete',
						)
					);
					return true;
				}
				// If we can't delete the original, remove the quarantine copy
				@unlink($quarantinePath);
			}

			// Fallback 2: Try to make file inaccessible
			if ($this->makeFileInaccessible($path)) {
				$this->logger->warning(
					'File made inaccessible as quarantine fallback',
					array(
						'path'   => $path,
						'method' => 'chmod',
					)
				);
				return true;
			}

			throw new Exception('All quarantine methods failed');
		} catch (Exception $e) {
			$this->logger->error(
				'Quarantine failed',
				array(
					'path'  => $path,
					'error' => $e->getMessage(),
					'trace' => $e->getTraceAsString(),
				)
			);
			return false;
		}
	}

	/**
	 * Make a file inaccessible as a last resort.
	 *
	 * @param string $path Path to the file
	 * @return bool True if successful, false otherwise
	 */
	private function makeFileInaccessible($path)
	{
		// Try to remove all permissions
		if (@chmod($path, 0000)) {
			return true;
		}

		// Fallback: try to make file unreadable
		if (@chmod($path, 0333)) {
			return true;
		}

		return false;
	}

	/**
	 * Handle exceptions with proper logging and notifications.
	 *
	 * @param Exception $e The exception to handle
	 * @param string $context Additional context about where the exception occurred
	 */
	private function handleException(Exception $e, $context = '')
	{
		$severity = ($e instanceof OMS_Exception) ? 'HIGH' : 'CRITICAL';

		// Log the error with full context
		$this->logger->error(sprintf(
			"%s: %s\nStack trace: %s",
			$context,
			$e->getMessage(),
			$e->getTraceAsString()
		));

		// Notify admin based on severity
		if ($this->shouldNotifyAdmin($severity)) {
			$this->notifyAdmin($context, $e);
		}
	}

	/**
	 * Check if admin should be notified based on severity and settings.
	 *
	 * @param string $severity The severity level to check
	 * @return bool Whether admin should be notified
	 */
	private function shouldNotifyAdmin($severity)
	{
		$severityLevel = OMS_Config::SEVERITY_LEVELS[$severity] ?? OMS_Config::SEVERITY_LEVELS['LOW'];
		$thresholdLevel = OMS_Config::SEVERITY_LEVELS[OMS_Config::NOTIFICATION_THRESHOLD] ?? OMS_Config::SEVERITY_LEVELS['MEDIUM'];

		return $severityLevel >= $thresholdLevel;
	}

	/**
	 * Send notification to admin.
	 *
	 * @param string $context The context of the notification
	 * @param Exception $e The exception that triggered the notification
	 */
	private function notifyAdmin($context, Exception $e)
	{
		try {
			$admin_email = get_option('admin_email');
			if (!$admin_email) {
				throw new OMS_Exception('Admin email not configured');
			}

			$site_name = get_bloginfo('name');
			$subject = sprintf('Security Alert - %s', $site_name);

			$body = sprintf(
				"Security issue detected:\n\nContext: %s\nError ID: %s\nTime: %s\nMessage: %s\nStack trace: %s",
				$context,
				uniqid('OMS_ERR_'),
				current_time('mysql'),
				$e->getMessage(),
				$e->getTraceAsString()
			);

			wp_mail($admin_email, $subject, $body);
			$this->logger->info("Security notification sent to admin: $admin_email");
		} catch (Exception $notifyError) {
			$this->logger->error("Failed to send admin notification: " . $notifyError->getMessage());
		}
	}

	/**
	 * Cleanup plugins.
	 */
	public function cleanupPlugins()
	{
		$this->logger->info('Starting plugin cleanup');

		// Get all installed plugins
		$plugins = get_plugins();
		foreach ($plugins as $pluginPath => $pluginData) {
			$fullPath = WP_PLUGIN_DIR . '/' . $pluginPath;

			// Scan each plugin file
			$files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($fullPath));
			foreach ($files as $file) {
				if ($file->isFile()) {
					$path = $file->getPathname();

					// Check for malware patterns
					if ($this->containsMalware($path)) {
						$this->logger->warning("Malware detected in plugin file: $path");
						$this->quarantineFile($path);
					}
				}
			}
		}

		$this->logger->info('Plugin cleanup completed');
	}

	/**
	 * Cleanup uploads.
	 */
	public function cleanupUploads()
	{
		$this->logger->info('Starting uploads cleanup');

		$uploadsDir = WP_CONTENT_DIR . '/uploads';
		$files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($uploadsDir));
		foreach ($files as $file) {
			if ($file->isFile()) {
				$path = $file->getPathname();

				// Validate the file
				$validationResult = $this->validateFile($path);
				if (!$validationResult['valid']) {
					$this->logger->warning("Suspicious file detected: $path - Reason: {$validationResult['reason']}");
					$this->quarantineFile($path);
				}
			}
		}

		$this->logger->info('Uploads cleanup completed');
	}

	/**
	 * Validate file.
	 */
	public function validateFile( $path ) {
		$this->logger->info( "Validating file: $path" );

		try {
			// Check file size.
			$filesize = filesize( $path );
			if ( $filesize > OMS_Config::SCAN_CONFIG['max_file_size'] ) {
				$this->logger->warning(
					sprintf(
						'File exceeds maximum size limit: %s (%d bytes)',
						$path,
						$filesize
					),
					'warning'
				);
				return false;
			}

			// Check file permissions.
			$perms = fileperms( $path ) & 0777;
			if ( $perms > OMS_Config::SCAN_CONFIG['allowed_permissions']['file'] ) {
				$this->logger->warning(
					sprintf(
						'File has unsafe permissions: %s (0%o)',
						$path,
						$perms
					),
					'warning'
				);
				return false;
			}

			// Skip excluded files.
			$basename = basename( $path );
			if ( in_array( $basename, OMS_Config::SCAN_CONFIG['excluded_files'], true ) ) {
				return true;
			}

			// Check for zero-byte files.
			if ( 0 === $filesize ) {
				$this->logger->warning( "Zero-byte file detected: $path", 'warning' );
				return false;
			}

			// Then check other malicious patterns.
			$chunk_size = $this->calculateOptimalChunkSize();
			return $this->scanFileChunks( $path, $chunk_size );
		} catch ( Exception $e ) {
			$this->handleException( $e, "Error validating file: $path" );
			return false;
		}
	}

	/**
	 * Cleanup quarantine.
	 */
	public function cleanupQuarantine()
	{
		try {
			$quarantinePath = OMS_Config::QUARANTINE_CONFIG['path'];
			$retentionDays = OMS_Config::QUARANTINE_CONFIG['retention_days'];
			$maxSize = OMS_Config::QUARANTINE_CONFIG['max_size'];

			if (!is_dir($quarantinePath)) {
				return;
			}

			$cutoffTime = strtotime("-{$retentionDays} days");
			$totalSize = 0;
			$files = new RecursiveIteratorIterator(
				new RecursiveDirectoryIterator($quarantinePath, RecursiveDirectoryIterator::SKIP_DOTS)
			);

			foreach ($files as $file) {
				if ($file->getMTime() < $cutoffTime) {
					unlink($file->getPathname());
					continue;
				}

				$totalSize += $file->getSize();
			}

			// If quarantine exceeds max size, remove oldest files
			if ($totalSize > $maxSize) {
				$files = iterator_to_array($files);
				usort($files, function ($a, $b) {
					return $a->getMTime() - $b->getMTime();
				});

				foreach ($files as $file) {
					if ($totalSize <= $maxSize) {
						break;
					}
					$totalSize -= $file->getSize();
					unlink($file->getPathname());
				}
			}
		} catch (Exception $e) {
			$this->handleException($e, 'Error cleaning up quarantine');
		}
	}

	/**
	 * Check file permissions.
	 */
	public function checkFilePermissions() {
		$this->logger->info( 'Starting file permissions check' );

		$directories = array(
			ABSPATH,
			WP_CONTENT_DIR,
			WP_CONTENT_DIR . '/uploads',
			WP_PLUGIN_DIR,
		);

		$secure_dir_perms  = OMS_Config::SCAN_CONFIG['allowed_permissions']['dir'];
		$secure_file_perms  = OMS_Config::SCAN_CONFIG['allowed_permissions']['file'];

		foreach ( $directories as $directory ) {
			$items = new RecursiveIteratorIterator( new RecursiveDirectoryIterator( $directory ) );
			foreach ( $items as $item ) {
				$path = $item->getPathname();

				$current_perms = fileperms( $path ) & 0777;

				if ( $item->isDir() && $current_perms !== $secure_dir_perms ) {
					if ( chmod( $path, $secure_dir_perms ) ) {
						$this->logger->info( "Corrected directory permissions: $path" );
					} else {
						$this->logger->error( "Failed to correct directory permissions: $path" );
					}
				} elseif ( $item->isFile() && $current_perms !== $secure_file_perms ) {
					if ( chmod( $path, $secure_file_perms ) ) {
						$this->logger->info( "Corrected file permissions: $path" );
					} else {
						$this->logger->error( "Failed to correct file permissions: $path" );
					}
				}
			}
		}

		$this->logger->info( 'File permissions check completed' );
	}

	/**
	 * Get core checksums.
	 */
	public function getCoreChecksums()
	{
		$this->logger->info('Retrieving WordPress core checksums');

		try {
			global $wp_version;
			$locale = get_locale();

			// Check cache first
			$cacheKey = "wp_checksums_{$wp_version}_{$locale}";
			$cachedChecksums = $this->cache->get($cacheKey);
			if ($cachedChecksums) {
				return $cachedChecksums;
			}

			// Construct API URL
			$url = sprintf(
				'https://api.wordpress.org/core/checksums/1.0/?version=%s&locale=%s',
				$wp_version,
				$locale
			);

			// Fetch checksums from WordPress API
			$response = wp_remote_get($url);
			if (is_wp_error($response)) {
				throw new Exception('Failed to fetch WordPress checksums: ' . $response->get_error_message());
			}

			$body = wp_remote_retrieve_body($response);
			$data = json_decode($body, true);

			if (empty($data) || !isset($data['checksums']) || !is_array($data['checksums'])) {
				throw new Exception('Invalid checksum data received from WordPress API');
			}

			// Cache the checksums
			$this->cache->set($cacheKey, $data['checksums'], 3600); // Cache for 1 hour

			$this->logger->info('Successfully retrieved WordPress core checksums');
			return $data['checksums'];
		} catch (Exception $e) {
			$this->logger->error('Error retrieving WordPress core checksums: ' . $e->getMessage());
			return array();
		}
	}

	/**
	 * Download file.
	 */
	public function downloadFile($url, $destination)
	{
		$this->logger->info("Downloading file from: $url to: $destination");

		try {
			// Validate URL
			if (!filter_var($url, FILTER_VALIDATE_URL)) {
				throw new Exception('Invalid URL provided');
			}

			// Validate destination directory
			$destDir = dirname($destination);
			if (!is_dir($destDir)) {
				if (!mkdir($destDir, 0755, true)) {
					throw new Exception("Failed to create destination directory: $destDir");
				}
			}

			if (!is_writable($destDir)) {
				throw new Exception("Destination directory is not writable: $destDir");
			}

			// Download file using WordPress functions
			$response = wp_remote_get($url, array(
				'timeout' => 300,
				'stream' => true,
				'filename' => $destination
			));

			if (is_wp_error($response)) {
				throw new Exception('Download failed: ' . $response->get_error_message());
			}

			// Verify file was downloaded
			if (!file_exists($destination)) {
				throw new Exception('File download failed: File not found at destination');
			}

			// Verify file size.
			$file_size = filesize( $destination );
			if ( 0 === $file_size ) {
				unlink( $destination );
				throw new Exception( 'Downloaded file is empty' );
			}

			$this->logger->info( "File downloaded successfully: $destination" );
			return true;
		} catch ( Exception $e ) {
			$this->logger->error( 'File download error: ' . $e->getMessage() );
			if ( file_exists( $destination ) ) {
				unlink( $destination );
			}
			return false;
		}
	}

	/**
	 * Critical error handler.
	 */
	public function critical($message)
	{
		// Log critical error with timestamp and backtrace
		$timestamp = current_time('mysql');
		$backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 3);
		$caller = isset($backtrace[1]) ? $backtrace[1]['function'] : 'unknown';

		$logMessage = sprintf(
			'[%s] CRITICAL ERROR in %s: %s',
			$timestamp,
			$caller,
			$message
		);

		// Log to WordPress error log
		error_log($logMessage);

		// Log to our custom log
		$this->logger->error($logMessage);

		// Notify admin if enabled and critical errors notifications are enabled
		if (
			self::OMS_NOTIFY_ADMIN['enabled'] &&
			self::OMS_NOTIFY_ADMIN['notification_types']['critical_errors']
		) {
			$admin_email = get_option('admin_email');
			$site_name = get_bloginfo('name');

			$subject = 'Critical Security Alert - ' . get_bloginfo('name');
			$body = sprintf(
				"Critical security issue detected:\n\nError ID: %s\nTime: %s\nMessage: %s\n%s",
				uniqid('OMS_ERR_'),
				$timestamp,
				$message,
				self::OMS_NOTIFY_ADMIN['include_context'] ? "\nContext: " . $caller : ''
			);

			wp_mail($admin_email, $subject, $body);

			// Store in database for audit trail
			if (function_exists('update_option')) {
				$audit_log = get_option('oms_security_audit_log', array());
				$audit_log[] = array(
					'timestamp' => $timestamp,
					'level' => 'CRITICAL',
					'message' => $message,
					'caller' => $caller
				);

				// Keep only last 100 entries
				if (count($audit_log) > 100) {
					$audit_log = array_slice($audit_log, -100);
				}

				update_option('oms_security_audit_log', $audit_log);
			}
		}

		// Perform cleanup if necessary @TODO CLeanup of WHAT?
		if (isset($context['cleanup_required']) && $context['cleanup_required']) {
			$this->runFullCleanup($context);
		}
	}

	/**
	 * Calculate optimal chunk size.
	 */
	public function calculateOptimalChunkSize()
	{
		try {
			// Get PHP memory limit
			$memoryLimit = $this->getMemoryLimit();

			// Get available memory
			$availableMemory = $this->getAvailableMemory();

			// Get disk space
			$availableDiskSpace = disk_free_space(ABSPATH);

			// Calculate base chunk size (20% of available memory)
			$baseChunkSize = (int)($availableMemory * 0.2);

			// Apply constraints
			$minChunkSize = 1024 * 1024;      // 1MB minimum
			$maxChunkSize = 5 * 1024 * 1024;  // 5MB maximum

			// Adjust based on available disk space
			if ($availableDiskSpace < $baseChunkSize * 10) {
				$baseChunkSize = (int)($availableDiskSpace * 0.1);
			}

			// Ensure chunk size is within bounds
			$chunkSize = max($minChunkSize, min($baseChunkSize, $maxChunkSize));

			$this->logger->info(sprintf(
				'Calculated optimal chunk size: %d bytes (Memory: %d, Disk: %d)',
				$chunkSize,
				$availableMemory,
				$availableDiskSpace
			));

			return $chunkSize;
		} catch (Exception $e) {
			$this->logger->error('Error calculating chunk size: ' . $e->getMessage());
			return 1024 * 1024; // Return 1MB as safe default
		}
	}

	private function getMemoryLimit() {
		$memory_limit = ini_get( 'memory_limit' );
		if ( '-1' === $memory_limit ) {
			return PHP_INT_MAX;
		}

		if ( preg_match( '/^(\d+)(.)$/', $memory_limit, $matches ) ) {
			$value = (int) $matches[1];
			$unit  = strtolower( $matches[2] );
			switch ( $unit ) {
				case 'g':
					$value *= 1024;
					// Fall through.
				case 'm':
					$value *= 1024;
					// Fall through.
				case 'k':
					$value *= 1024;
			}
			return $value;
		}

		return 128 * 1024 * 1024; // 128MB default.
	}

	private function getAvailableMemory()
	{
		$memoryLimit = $this->getMemoryLimit();
		$memoryUsage = memory_get_usage(true);
		$availableMemory = $memoryLimit - $memoryUsage;

		return max(0, $availableMemory);
	}

	/**
	 * Check if should throttle.
	 */
	public function shouldThrottle()
	{
		try {
			// Check if rate limiting is enabled
			if (!defined('OMS_RATE_LIMIT_ENABLED')) {
				define('OMS_RATE_LIMIT_ENABLED', true);
			}

			if (!OMS_RATE_LIMIT_ENABLED) {
				return false;
			}

			// Check server load
			if (function_exists('sys_getloadavg')) {
				$load = sys_getloadavg();
				$maxLoad = OMS_Config::RATE_LIMIT_CONFIG['max_cpu_load'];

				if ($load[0] > $maxLoad) {
					$this->logger->warning(sprintf('High server load detected: %.2f', $load[0]));
					return true;
				}
			}

			// Check memory usage
			$memoryUsage = memory_get_usage(true);
			$memoryLimit = $this->getMemoryLimit();
			$maxMemoryPercent = OMS_Config::RATE_LIMIT_CONFIG['max_memory_percent'];

			if (($memoryUsage / $memoryLimit) * 100 > $maxMemoryPercent) {
				$this->logger->warning(sprintf(
					'High memory usage detected: %.2f%%',
					($memoryUsage / $memoryLimit) * 100
				));
				return true;
			}

			// Check request rate
			$requestKey = 'oms_request_count_' . date('Y-m-d-H');
			$requestCount = (int)get_transient($requestKey);
			$maxRequests = OMS_Config::RATE_LIMIT_CONFIG['requests_per_hour'];

			if ($requestCount > $maxRequests) {
				$this->logger->warning('Request limit exceeded for current hour');
				return true;
			}

			// Increment request count
			set_transient($requestKey, $requestCount + 1, HOUR_IN_SECONDS);

			// Check peak hours
			$hour = (int)current_time('G');
			$peakStart = OMS_Config::RATE_LIMIT_CONFIG['peak_hour_start'];
			$peakEnd = OMS_Config::RATE_LIMIT_CONFIG['peak_hour_end'];

			if ($hour >= $peakStart && $hour <= $peakEnd) {
				// During peak hours, be more conservative
				if ($load[0] > $maxLoad * 0.8) {
					$this->logger->info('Throttling during peak hours');
					return true;
				}
			}

			return false;
		} catch (Exception $e) {
			$this->logger->error('Error in throttle check: ' . $e->getMessage());
			return true; // Throttle on error to be safe
		}
	}

	/**
	 * Extract match context.
	 */
	public function extractMatchContext($file, $pattern)
	{
		$this->logger->info("Extracting context for pattern matches in: $file");

		try {
			if (!file_exists($file) || !is_readable($file)) {
				throw new Exception("File not accessible: $file");
			}

			// Read file content in chunks to handle large files.
			$handle = fopen( $file, 'r' );
			if ( false === $handle ) {
				throw new Exception( "Failed to open file: $file" );
			}

			$matches      = array();
			$line_number  = 0;
			$context_lines = 3; // Number of lines before and after match.
			$buffer       = array();

			// Read file line by line.
			while ( ! feof( $handle ) ) {
				$line = fgets( $handle );
				if ( false === $line ) {
					break;
				}

				$lineNumber++;

				// Keep a rolling buffer of recent lines
				$buffer[] = array(
					'number' => $lineNumber,
					'content' => rtrim($line)
				);

				// Keep only necessary lines in buffer
				if (count($buffer) > $contextLines * 2 + 1) {
					array_shift($buffer);
				}

				// Check for pattern match
				if (preg_match($pattern, $line)) {
					// Calculate context range
					$contextStart = max(0, count($buffer) - $contextLines - 1);
					$context = array_slice($buffer, $contextStart);

					// Store match with context
					$matches[] = array(
						'line' => $lineNumber,
						'context' => $context,
						'match' => trim($line)
					);

					// Log the match
					$this->logger->warning(sprintf(
						'Found match in %s on line %d: %s',
						$file,
						$lineNumber,
						substr(trim($line), 0, 100) . (strlen($line) > 100 ? '...' : '')
					));
				}
			}

			fclose($handle);

			// Format the output
			$output = array();
			foreach ($matches as $match) {
				$contextStr = "Match on line {$match['line']}:\n";
				foreach ($match['context'] as $contextLine) {
					$prefix = $contextLine['number'] === $match['line'] ? '>' : ' ';
					$contextStr .= sprintf(
						"%s %4d: %s\n",
						$prefix,
						$contextLine['number'],
						$this->sanitizeOutput($contextLine['content'])
					);
				}
				$output[] = $contextStr;
			}

			return array(
				'file' => $file,
				'pattern' => $pattern,
				'matches' => count($matches),
				'contexts' => $output
			);
		} catch (Exception $e) {
			$this->logger->error('Error extracting match context: ' . $e->getMessage());
			return array(
				'file' => $file,
				'pattern' => $pattern,
				'matches' => 0,
				'contexts' => array(),
				'error' => $e->getMessage()
			);
		}
	}

	private function sanitizeOutput($content)
	{
		// Remove null bytes and control characters
		$content = str_replace("\0", '', $content);
		$content = preg_replace('/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/', '', $content);

		// Encode special characters for safe display
		return htmlspecialchars($content, ENT_QUOTES, 'UTF-8');
	}
}
